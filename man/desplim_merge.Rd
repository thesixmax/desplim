% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/desplim_merge.R
\name{desplim_merge}
\alias{desplim_merge}
\title{Deterministically merge a set of polygons with possible parameters defined by
the user.}
\usage{
desplim_merge(
  input_polygons,
  input_buildings = NULL,
  compact_method = "desplim",
  compact_threshold = 0.7,
  compact_allow = 0.2,
  area_threshold = 10000,
  enclosed_threshold = 0.8,
  building_threshold = 5
)
}
\arguments{
\item{input_polygons}{object of class sf of type POLYGON to be merged.}

\item{input_buildings}{object of class sf of type POLYGON or MULTIPOLYGON.
An optional sf object representing buildings which should be considered when
merging. Default is \code{NULL}.}

\item{compact_method}{string; chosen method for calculating compactness of
polygons. Default is \code{"desplim"}, using the internal \code{desplim_compactness}
function. Other options include \code{"polsby"}, \code{"schwartz"} and \code{"convex_hull"}
from the \code{redistmetrics} package.}

\item{compact_threshold}{numerical; the baseline expected compactness of the
output polygons. Default is 0.7.}

\item{compact_allow}{numerical; the fraction of polygons allowed to fall
below \code{compact_tolerance}. Default is 0.2.}

\item{area_threshold}{numerical; the minimum required area of merged
polygons. Default is 10000 units.}

\item{enclosed_threshold}{numerical; the fraction of a polygon border shared
with a single neighbour for it to be considered enclosed (and flagged for
merging). Default is 0.8.}

\item{building_threshold}{integer; the minimum number of required buildings
within merged polygons if \code{input_buildings} is provided. Default is 5, but
sis set to 0 if \code{input_buildings} is not provided.}
}
\value{
An sf object of POLYGONs resulting from the deterministic merge.
}
\description{
Function for merging a set of polygons, with optinal rules
defined by the user. The merging process is deterministic, leading to
reproducible results on subsequent runs with the same input data and rules.
}
\details{
There are no requirements for all polygons being adjacent to each
other. Although named \code{input_buildings}, any sf object of type POLYGON or
MULTIPOLYGON can be provided for this argument. For details about the
compactness metric, please see the dedicated vignette. It is not recommended
to set \code{compact_allow} too close to 1 and \code{compact_tolerance} too low.
This is especially true if \code{compact_method} is set to \code{"polsby"}.
}
\examples{
# Create grid
crs <- 32632
grid_area <- sf::st_bbox(
  c(xmin = 0, ymin = 0, xmax = 1200, ymax = 1000),
  crs = crs
)
grid_poly <- sf::st_as_sf(sf::st_make_grid(
  grid_area,
  cellsize = 100,
  square = TRUE
))
plot(sf::st_geometry(grid_poly), border = 'grey')

# Create buildings
n_buildings <- 100
set.seed(420)
building_centers <- sf::st_sample(sf::st_as_sfc(grid_area), size = n_buildings)
list_of_buildings <- lapply(sf::st_geometry(building_centers), function(point) {
  x <- point[1]
  y <- point[2]
  width <- runif(1, min = 5, max = 20)
  height <- runif(1, min = 5, max = 20)
  corners <- rbind(
    c(x - width / 2, y - height / 2),
    c(x + width / 2, y - height / 2),
    c(x + width / 2, y + height / 2),
    c(x - width / 2, y + height / 2),
    c(x - width / 2, y - height / 2)
  )
  sf::st_as_sf(sf::st_sfc(sf::st_polygon(list(corners))), crs = crs)
})
buildings_sf <- do.call(rbind, list_of_buildings)
plot(sf::st_geometry(buildings_sf), col = 'slateblue3', border = NA, add = TRUE)

# Merge with default settings
grid_merged <- desplim_merge(
  input_polygon = grid_poly,
  input_buildings = buildings_sf
)
print(grid_merged, n = nrow(grid_merged))
plot(sf::st_geometry(grid_merged), lwd = 4, border = 'tomato3', add = TRUE)
}
