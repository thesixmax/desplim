% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/desplim_line_nearest_node.R
\name{desplim_line_nearest_node}
\alias{desplim_line_nearest_node}
\title{Calculate the minimum distance linestring from an \code{sf} POINT object to nodes
of a \code{sf} LINESTRING object}
\usage{
desplim_line_nearest_node(
  input_nodes,
  input_lines,
  input_buildings = NULL,
  cast_substring = TRUE,
  combine_nodes = TRUE,
  ignore_equal = TRUE
)
}
\arguments{
\item{input_nodes}{object of class sf with geometry type POINT or MULTIPOINT.}

\item{input_lines}{object of class sf with geometry type LINESTRING or
MULTILINESTRING.}

\item{input_buildings}{optional object of class sf with geometry type POLYGON
or MULTIPOLYGON to not be crossed.}

\item{cast_substring}{logical; should the input linestring be cast to
substring? Default is \code{TRUE}.}

\item{combine_nodes}{logical; should the input nodes and nodes of the input
lines be combined? Default is \code{TRUE}.}

\item{ignore_equal}{logical; should output linestrings which are exactly
equal to one or more elements in \code{input_lines} be ignored? Default is \code{TRUE}.}
}
\value{
An \code{sf} object of type LINESTRING containing the minimum distance
linestrings from each node in \code{input_nodes} to nodes in \code{input_lines} or the
combined set of \code{input_nodes} and nodes in \code{input_lines}.
}
\description{
Calculate the minimum distance linestring connection from an
\code{sf} POINT object to nodes of an \code{sf} LINESTRING object
}
\details{
For each input node, the function computes the minimum distance to
the chosen set of nodes and outputs the minimum distance linestrings. In
cases where the minimum distance is zero, due to overlap of the input node
and one or more nodes in \code{input_lines}, the second minimum distance
linestring is computed. If \code{input_nodes} or \code{input_lines} contain geometries
of type MULTIPOINT or MULTILINESTRING, they are converted to POINT and
LINESTRING respectively before computing.
}
\examples{
# Create nodes, lines and a building
crs <- 32632
line1 <- sf::st_linestring(rbind(c(0, 10), c(10, 10)))
line2 <- sf::st_linestring(rbind(c(10, 10), c(10, 0)))
lines_sf <- sf::st_as_sf(sf::st_sfc(line1, line2, crs = crs))

node1 <- sf::st_point(c(3, 6))
node2 <- sf::st_point(c(8, 4))
points_sf <- sf::st_as_sf(sf::st_sfc(node1, node2, crs = crs))

building_poly <- sf::st_polygon(list(rbind(
  c(1, 7),
  c(1, 9),
  c(4, 9),
  c(4, 7),
  c(1, 7)
)))
building_sf <- sf::st_as_sf(sf::st_sfc(building_poly, crs = crs))

# Compute connections with no building
connections_no_building <- desplim_line_nearest_node(points_sf, lines_sf)
print(connections_no_building)

# Visualise
plot(sf::st_geometry(lines_sf), col = "black", lwd = 2)
plot(sf::st_geometry(points_sf), col = "slateblue3", pch = 16, cex = 2, add = TRUE)
plot(sf::st_geometry(connections_no_building), col = "olivedrab", lwd = 2, add = TRUE)

# Compute connections with building
connections_with_building <- desplim_line_nearest_node(
  input_nodes = points_sf,
  input_lines = lines_sf,
  input_buildings = building_sf
)
print(connections_with_building)

# Visualise
plot(sf::st_geometry(lines_sf), col = "black", lwd = 2)
plot(sf::st_geometry(building_sf), col = "tomato3", border = NA, add = TRUE)
plot(sf::st_geometry(points_sf), col = "blue", pch = 16, cex = 2, add = TRUE)
plot(sf::st_geometry(connections_with_building), col = "green", lwd = 2, add = TRUE)
}
