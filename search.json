[{"path":"https://thesixmax.github.io/desplim/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 Sixten Maximillian Thestrup Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://thesixmax.github.io/desplim/articles/DESPLIM-compactness.html","id":"setup-and-data","dir":"Articles","previous_headings":"","what":"Setup and data","title":"Creating DESPLIM compactness","text":"paper Kaufman et al (2021) employs novel method determine quantitative metric legislative district compactness designed replicate intuitive “know see ” standard often cited law. resulting metric output statistical model trained predict human rankings district shapes based different geometric district features. Overall, shows promising results accurately predicting diverse groups intuitively judge district’s compactness based solely well-known geometric features. found relevant include similar compactness metric package, replication exercise, fits well overall objective deterministic algorithm split-merge larger districts. However, since compactness metric calculated thousands, millions, times complex split-merge problems, found natural rely single model file fast implementations calculation typical geometrical district features. obtain goal, implemented simple XGBoost model described , based excellent replication data provided Kaufman et al. start, install load packages used modelling diagnostics: important note parallel computation course completely optional, speed model tuning process. Next, can get quick glance cleaned training data.  details data can found associated data documentation. short, data processing consists three steps: Merge original district shape files human-assigned compactness scores replication data. district, compute 10 different geometrical features using redistmetrics. Rescale compactness score 0 (lowest compactness) 1 (highest compactness). resulting data consists 558 districts. shown plot, training data contains close uniform distribution compactness, essential model learn full range possible compactness scores. Also, data snippet reveal obvious correlation compactness single geometrical feature. Next, data split training data (80%) test data (20%), simple recipe processing steps created.","code":"library(desplim) # contains cleaned training data library(tidymodels) # preferred modelling framework library(xgboost) # model engine library(DALEX) # model checks and diagnostics library(DALEXtra) library(doFuture) # parallel processing registerDoFuture() plan(multisession, workers = parallel::detectCores(logical = FALSE) - 1) options(tidymodels.dark = TRUE) # for those of us who love a good dark theme head(desplim_compactness_data) #>     compact     boyce box_reock      hull   len_wid    polsby     reock #> 1 0.0300000 0.7649550 0.4896064 0.6262075 0.7534825 0.1145953 0.4057489 #> 2 0.2745098 0.7775373 0.4381054 0.6984327 0.8969073 0.2021440 0.3742773 #> 3 0.1300000 0.8304922 0.4871881 0.6415116 0.8888942 0.1258987 0.3280131 #> 4 0.1400000 0.8341214 0.4310280 0.6125937 0.6679481 0.1873192 0.3345650 #> 5 0.0100000 0.7016934 0.4300677 0.5800668 0.9635191 0.1019103 0.4143697 #> 6 0.1176471 0.8371308 0.3508467 0.5589451 0.3416772 0.1458956 0.1486579 #>    schwartz      skew     sym_x     sym_y #> 1 0.3385193 0.2822636 0.6494468 0.5977191 #> 2 0.4496043 0.4190817 0.6090472 0.6896901 #> 3 0.3548220 0.2738264 0.5287228 0.5271888 #> 4 0.4328039 0.3005736 0.4305575 0.3530961 #> 5 0.3192339 0.2754020 0.4761292 0.4987708 #> 6 0.3819629 0.1683645 0.6358400 0.4629123 hist(desplim_compactness_data$compact) set.seed(123) # Data split data_split <- initial_split(desplim_compactness_data, prop = 0.8, strata = compact) train_data <- training(data_split) test_data <- testing(data_split)  # Recipe model_recipe <- recipe(compact ~ ., data = train_data)"},{"path":"https://thesixmax.github.io/desplim/articles/DESPLIM-compactness.html","id":"model-specification-and-tuning","dir":"Articles","previous_headings":"","what":"Model specification and tuning","title":"Creating DESPLIM compactness","text":"model compactness score, employed ever--popular XGBoost algorithm. Within tidyverse framework, option tune model parameters see fit. information, documentation tune package comes handy. case, since dataset small need worry computational issues, reasonable tune standard model parameters. parameter specification, can apply defaults provided dials package. tuning model, need put model recipe model specifications workflow. Finally, also define 10-fold cross-validation iteration. Even though e.g. 5-fold cross-validation likely sufficient case, worry computing time, especially utilising parallel processing. Tuning time! model, apply Bayesian tuning. Compared e.g. brute-force grid search, tests every combination predefined set parameters, Bayesian tuning applies adaptive strategy based probabilistic models search promising areas parameter space. RMSE (root mean squared error) used model comparison evaluation. minutes, can obtain best parameters model lowest RMSE. wrap modelling finalising workflow, fit test data collect predictions.","code":"# XGBoost specification xgb_spec <- boost_tree(   trees = tune(),   tree_depth = tune(),   learn_rate = tune(),   mtry = tune(),   min_n = tune(),   loss_reduction = tune(),   sample_size = tune() ) |>   set_engine(     \"xgboost\",     objective = \"reg:squarederror\",     verbose = 0   ) |>   set_mode(\"regression\")  # XGBoost parameter specification xgb_params <- parameters(   trees(),   tree_depth(),   learn_rate(),   finalize(mtry(), train_data),   min_n(),   loss_reduction(),   sample_prop() ) # Workflow xgb_workflow <- workflow() |>   add_recipe(model_recipe) |>   add_model(xgb_spec)  # Cross validation set.seed(456) cv_folds <- vfold_cv(train_data, v = 10) set.seed(789) tune_results <- tune_bayes(   xgb_workflow,   resamples = cv_folds,   param_info = xgb_params,   initial = 10,   iter = 100,   metrics = metric_set(rmse, mae),   control = control_bayes(     verbose_iter = TRUE,     save_pred = FALSE,     save_workflow = FALSE,     uncertain = 5,     no_improve = 20   ) ) #> Optimizing rmse using the expected improvement #>  #> ── Iteration 1 ───────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1078 (@iter 0) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> i trees=621, tree_depth=1, learn_rate=0.0987, mtry=10, min_n=19, #>   loss_reduction=2.94e-06, sample_size=0.65 #> i Estimating performance #> ✓ Estimating performance #> ♥ Newest results:  rmse=0.1072 (+/-0.00436) #>  #> ── Iteration 2 ───────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1072 (@iter 1) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> i trees=1000, tree_depth=6, learn_rate=0.0423, mtry=11, min_n=26, #>   loss_reduction=9.13e-06, sample_size=0.804 #> i Estimating performance #> ✓ Estimating performance #> ⓧ Newest results:  rmse=0.1103 (+/-0.00441) #>  #> ── Iteration 3 ───────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1072 (@iter 1) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> i trees=1461, tree_depth=4, learn_rate=0.0221, mtry=1, min_n=11, #>   loss_reduction=5.05e-06, sample_size=0.156 #> i Estimating performance #> ✓ Estimating performance #> ♥ Newest results:  rmse=0.1033 (+/-0.00473) #>  #> ── Iteration 4 ───────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1033 (@iter 3) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> i trees=1786, tree_depth=1, learn_rate=0.00586, mtry=7, min_n=20, #>   loss_reduction=3.44e-06, sample_size=0.308 #> i Estimating performance #> ✓ Estimating performance #> ⓧ Newest results:  rmse=0.1038 (+/-0.00448) #>  #> ── Iteration 5 ───────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1033 (@iter 3) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> i trees=1613, tree_depth=2, learn_rate=0.011, mtry=5, min_n=17, #>   loss_reduction=1.74e-06, sample_size=0.559 #> i Estimating performance #> ✓ Estimating performance #> ⓧ Newest results:  rmse=0.1044 (+/-0.00437) #>  #> ── Iteration 6 ───────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1033 (@iter 3) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> i trees=671, tree_depth=1, learn_rate=0.0141, mtry=5, min_n=27, #>   loss_reduction=3.24e-06, sample_size=0.203 #> i Estimating performance #> ✓ Estimating performance #> ⓧ Newest results:  rmse=0.1129 (+/-0.00401) #>  #> ── Iteration 7 ───────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1033 (@iter 3) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> i trees=1733, tree_depth=2, learn_rate=0.0493, mtry=8, min_n=22, #>   loss_reduction=2.27e-05, sample_size=0.507 #> i Estimating performance #> ✓ Estimating performance #> ⓧ Newest results:  rmse=0.1115 (+/-0.00443) #>  #> ── Iteration 8 ───────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1033 (@iter 3) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> i trees=1827, tree_depth=13, learn_rate=0.0289, mtry=8, min_n=16, #>   loss_reduction=4.27e-06, sample_size=0.485 #> i Estimating performance #> ✓ Estimating performance #> ⓧ Newest results:  rmse=0.1118 (+/-0.00393) #>  #> ── Iteration 9 ───────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1033 (@iter 3) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> ?⃝ Uncertainty sample #> i trees=1513, tree_depth=14, learn_rate=4.22e-09, mtry=7, min_n=40, #>   loss_reduction=3.39e-10, sample_size=0.863 #> i Estimating performance #> ✓ Estimating performance #> ⓧ Newest results:  rmse=0.2816 (+/-0.00561) #>  #> ── Iteration 10 ──────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1033 (@iter 3) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> i trees=1828, tree_depth=5, learn_rate=0.0283, mtry=6, min_n=34, #>   loss_reduction=2.62e-06, sample_size=0.478 #> i Estimating performance #> ✓ Estimating performance #> ⓧ Newest results:  rmse=0.1092 (+/-0.0045) #>  #> ── Iteration 11 ──────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1033 (@iter 3) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> i trees=1278, tree_depth=5, learn_rate=0.0132, mtry=6, min_n=10, #>   loss_reduction=7.74e-06, sample_size=0.603 #> i Estimating performance #> ✓ Estimating performance #> ⓧ Newest results:  rmse=0.1075 (+/-0.00382) #>  #> ── Iteration 12 ──────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1033 (@iter 3) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> i trees=1977, tree_depth=5, learn_rate=0.0417, mtry=1, min_n=7, #>   loss_reduction=4.16e-06, sample_size=0.38 #> i Estimating performance #> ✓ Estimating performance #> ⓧ Newest results:  rmse=0.1102 (+/-0.00355) #>  #> ── Iteration 13 ──────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1033 (@iter 3) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> i trees=37, tree_depth=3, learn_rate=0.0886, mtry=9, min_n=4, #>   loss_reduction=0.000315, sample_size=0.331 #> i Estimating performance #> ✓ Estimating performance #> ♥ Newest results:  rmse=0.1028 (+/-0.00397) #>  #> ── Iteration 14 ──────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1028 (@iter 13) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> i trees=298, tree_depth=2, learn_rate=0.0953, mtry=6, min_n=31, #>   loss_reduction=1.5e-05, sample_size=0.938 #> i Estimating performance #> ✓ Estimating performance #> ⓧ Newest results:  rmse=0.1067 (+/-0.00467) #>  #> ── Iteration 15 ──────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1028 (@iter 13) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> i trees=1745, tree_depth=5, learn_rate=0.00753, mtry=9, min_n=8, #>   loss_reduction=0.0015, sample_size=0.77 #> i Estimating performance #> ✓ Estimating performance #> ⓧ Newest results:  rmse=0.1077 (+/-0.00411) #>  #> ── Iteration 16 ──────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1028 (@iter 13) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> i trees=1200, tree_depth=7, learn_rate=0.00656, mtry=6, min_n=11, #>   loss_reduction=1.21e-10, sample_size=0.249 #> i Estimating performance #> ✓ Estimating performance #> ♥ Newest results:  rmse=0.1027 (+/-0.00445) #>  #> ── Iteration 17 ──────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1027 (@iter 16) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> i trees=1090, tree_depth=3, learn_rate=0.00819, mtry=10, min_n=6, #>   loss_reduction=1.49e-10, sample_size=0.751 #> i Estimating performance #> ✓ Estimating performance #> ⓧ Newest results:  rmse=0.1046 (+/-0.00417) #>  #> ── Iteration 18 ──────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1027 (@iter 16) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> i trees=1574, tree_depth=13, learn_rate=0.0056, mtry=10, min_n=11, #>   loss_reduction=3.21e-10, sample_size=0.61 #> i Estimating performance #> ✓ Estimating performance #> ⓧ Newest results:  rmse=0.1069 (+/-0.00408) #>  #> ── Iteration 19 ──────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1027 (@iter 16) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> i trees=1514, tree_depth=2, learn_rate=0.0232, mtry=9, min_n=7, #>   loss_reduction=3.92, sample_size=0.247 #> i Estimating performance #> ✓ Estimating performance #> ⓧ Newest results:  rmse=0.2146 (+/-0.00476) #>  #> ── Iteration 20 ──────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1027 (@iter 16) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> i trees=1558, tree_depth=7, learn_rate=0.044, mtry=3, min_n=27, #>   loss_reduction=1.13e-10, sample_size=0.687 #> i Estimating performance #> ✓ Estimating performance #> ⓧ Newest results:  rmse=0.1108 (+/-0.00402) #>  #> ── Iteration 21 ──────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1027 (@iter 16) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> i trees=1581, tree_depth=3, learn_rate=0.00782, mtry=4, min_n=11, #>   loss_reduction=7.2e-05, sample_size=0.914 #> i Estimating performance #> ✓ Estimating performance #> ⓧ Newest results:  rmse=0.1049 (+/-0.00441) #>  #> ── Iteration 22 ──────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1027 (@iter 16) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> ?⃝ Uncertainty sample #> i trees=1281, tree_depth=13, learn_rate=5.63e-08, mtry=7, min_n=30, #>   loss_reduction=3.76e-06, sample_size=0.767 #> i Estimating performance #> ✓ Estimating performance #> ⓧ Newest results:  rmse=0.2816 (+/-0.00561) #>  #> ── Iteration 23 ──────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1027 (@iter 16) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> i trees=1981, tree_depth=1, learn_rate=0.0132, mtry=5, min_n=24, #>   loss_reduction=2.15e-10, sample_size=0.123 #> i Estimating performance #> ✓ Estimating performance #> ⓧ Newest results:  rmse=0.1191 (+/-0.00451) #>  #> ── Iteration 24 ──────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1027 (@iter 16) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> i trees=13, tree_depth=7, learn_rate=0.0135, mtry=9, min_n=18, #>   loss_reduction=0.000708, sample_size=0.609 #> i Estimating performance #> ✓ Estimating performance #> ⓧ Newest results:  rmse=0.245 (+/-0.00459) #>  #> ── Iteration 25 ──────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1027 (@iter 16) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> i trees=173, tree_depth=7, learn_rate=0.0847, mtry=10, min_n=36, #>   loss_reduction=1.38e-07, sample_size=0.495 #> i Estimating performance #> ✓ Estimating performance #> ⓧ Newest results:  rmse=0.1064 (+/-0.00381) #>  #> ── Iteration 26 ──────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1027 (@iter 16) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> i trees=438, tree_depth=3, learn_rate=0.0661, mtry=2, min_n=5, #>   loss_reduction=1.17e-07, sample_size=0.679 #> i Estimating performance #> ✓ Estimating performance #> ⓧ Newest results:  rmse=0.1091 (+/-0.00412) #>  #> ── Iteration 27 ──────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1027 (@iter 16) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> i trees=1231, tree_depth=2, learn_rate=0.033, mtry=3, min_n=13, #>   loss_reduction=1.89e-10, sample_size=0.255 #> i Estimating performance #> ✓ Estimating performance #> ⓧ Newest results:  rmse=0.1059 (+/-0.00421) #>  #> ── Iteration 28 ──────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1027 (@iter 16) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> ?⃝ Uncertainty sample #> i trees=1032, tree_depth=4, learn_rate=3.03e-10, mtry=2, min_n=25, #>   loss_reduction=6.11, sample_size=0.776 #> i Estimating performance #> ✓ Estimating performance #> ⓧ Newest results:  rmse=0.2816 (+/-0.00561) #>  #> ── Iteration 29 ──────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1027 (@iter 16) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> i trees=873, tree_depth=6, learn_rate=0.0115, mtry=5, min_n=31, #>   loss_reduction=5.31e-08, sample_size=0.297 #> i Estimating performance #> ✓ Estimating performance #> ⓧ Newest results:  rmse=0.1077 (+/-0.00416) #>  #> ── Iteration 30 ──────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1027 (@iter 16) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> i trees=898, tree_depth=7, learn_rate=0.0809, mtry=4, min_n=3, #>   loss_reduction=0.00013, sample_size=0.811 #> i Estimating performance #> ✓ Estimating performance #> ⓧ Newest results:  rmse=0.1086 (+/-0.0038) #>  #> ── Iteration 31 ──────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1027 (@iter 16) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> i trees=747, tree_depth=3, learn_rate=0.063, mtry=8, min_n=35, #>   loss_reduction=1.62e-08, sample_size=0.969 #> i Estimating performance #> ✓ Estimating performance #> ⓧ Newest results:  rmse=0.1099 (+/-0.00392) #>  #> ── Iteration 32 ──────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1027 (@iter 16) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> i trees=1824, tree_depth=11, learn_rate=0.00575, mtry=6, min_n=38, #>   loss_reduction=2.01e-07, sample_size=0.369 #> i Estimating performance #> ✓ Estimating performance #> ⓧ Newest results:  rmse=0.1072 (+/-0.00421) #>  #> ── Iteration 33 ──────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1027 (@iter 16) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> i trees=610, tree_depth=6, learn_rate=0.00522, mtry=8, min_n=29, #>   loss_reduction=2.11e-06, sample_size=0.994 #> i Estimating performance #> ✓ Estimating performance #> ⓧ Newest results:  rmse=0.1065 (+/-0.00391) #>  #> ── Iteration 34 ──────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1027 (@iter 16) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> ?⃝ Uncertainty sample #> i trees=1860, tree_depth=14, learn_rate=0.00014, mtry=3, min_n=28, #>   loss_reduction=1.03e-10, sample_size=0.856 #> i Estimating performance #> ✓ Estimating performance #> ⓧ Newest results:  rmse=0.2314 (+/-0.00422) #>  #> ── Iteration 35 ──────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1027 (@iter 16) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> i trees=967, tree_depth=2, learn_rate=0.00454, mtry=8, min_n=5, #>   loss_reduction=2.07e-05, sample_size=0.12 #> i Estimating performance #> ✓ Estimating performance #> ⓧ Newest results:  rmse=0.103 (+/-0.00426) #>  #> ── Iteration 36 ──────────────────────────────────────────────────────────────── #>  #> i Current best:       rmse=0.1027 (@iter 16) #> i Gaussian process model #> i Generating 5000 candidates #> i Predicted candidates #> i trees=562, tree_depth=3, learn_rate=0.0069, mtry=4, min_n=40, #>   loss_reduction=4.23e-07, sample_size=0.342 #> i Estimating performance #> ✓ Estimating performance #> ⓧ Newest results:  rmse=0.1111 (+/-0.00376) #> ! No improvement for 20 iterations; returning current results. best_params <- select_best(tune_results, metric = \"rmse\") print(best_params) #> # A tibble: 1 × 8 #>   trees tree_depth learn_rate  mtry min_n loss_reduction sample_size .config #>   <int>      <int>      <dbl> <int> <int>          <dbl>       <dbl> <chr>   #> 1  1200          7    0.00656     6    11       1.21e-10       0.249 iter016 final_xgb_wf <- finalize_workflow(xgb_workflow, best_params) final_fit <- last_fit(final_xgb_wf, data_split) test_predictions <- collect_predictions(final_fit) final_trained_workflow <- extract_workflow(final_fit)"},{"path":"https://thesixmax.github.io/desplim/articles/DESPLIM-compactness.html","id":"model-diagnostics","dir":"Articles","previous_headings":"","what":"Model diagnostics","title":"Creating DESPLIM compactness","text":"can carry checks investigate final fit model. First, test metrics: RMSE reasonably low, R-squared consequentially high. can plot predicted compactness versus actual compactness discover regions model performs better worse expected.  Aside couple outliers, model predict evenly well across compactness scores. Finally, can check geographical feature important determining compactness:  find Polsby-Popper Convex Hull important features. However, geographical features plays role predicting compactness score. create single XGBoost model object, can extract fit engine, saved used future predictions.","code":"test_metrics <- collect_metrics(final_fit) predicted_vs_actual_plot <- ggplot(   test_predictions,   aes(x = compact, y = .pred) ) +   geom_point(alpha = 0.5, color = \"dodgerblue\") +   geom_abline(lty = 2, color = \"red\", linewidth = 1) +   labs(     title = \"Predicted vs. Actual Compactness on test data\",     x = \"Actual compactness\",     y = \"Predicted compactness\"   ) +   theme_minimal(base_size = 14) +   coord_fixed() print(predicted_vs_actual_plot) train_predictors <- train_data |> select(-compact) train_outcome <- train_data$compact explainer <- explain_tidymodels(   final_trained_workflow,   data = train_predictors,   y = train_outcome,   label = \"XGBoost\" ) #> Preparation of a new explainer is initiated #>   -> model label       :  XGBoost  #>   -> data              :  445  rows  10  cols  #>   -> target variable   :  445  values  #>   -> predict function  :  yhat.workflow  will be used (  default  ) #>   -> predicted values  :  No value for predict function target column. (  default  ) #>   -> model_info        :  package tidymodels , ver. 1.4.0 , task regression (  default  )  #>   -> predicted values  :  numerical, min =  0.063353 , mean =  0.5173986 , max =  0.9554381   #>   -> residual function :  difference between y and yhat (  default  ) #>   -> residuals         :  numerical, min =  -0.1965148 , mean =  -0.0001375619 , max =  0.3349416   #>   A new explainer has been created! feature_importance <- model_parts(explainer) plot(feature_importance, max_vars = Inf) final_xgb_model_engine <- extract_fit_engine(final_trained_workflow)"},{"path":"https://thesixmax.github.io/desplim/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Sixten Maximillian Thestrup. Author, maintainer.","code":""},{"path":"https://thesixmax.github.io/desplim/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Thestrup S (2025). desplim: DESPLIM algorithm R. R package version 0.1.0, https://thesixmax.github.io/desplim/.","code":"@Manual{,   title = {desplim: DESPLIM algorithm in R},   author = {Sixten Maximillian Thestrup},   year = {2025},   note = {R package version 0.1.0},   url = {https://thesixmax.github.io/desplim/}, }"},{"path":"https://thesixmax.github.io/desplim/index.html","id":"desplim-implementation-of-the-desplim-algorithm-in-r","dir":"","previous_headings":"","what":"DESPLIM algorithm in R","title":"DESPLIM algorithm in R","text":"package implementation DESPLIM (deterministic split-merge) algorithm geospatial districting R. associated paper forthcoming. Aside main algorithm, package contains several helper functions, can utilised working sf LINESTRING POLYGON data.","code":""},{"path":"https://thesixmax.github.io/desplim/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"DESPLIM algorithm in R","text":"package depends spatial package sf. recommended install package first. Execute following install latest version desplim:","code":"library(devtools) install_github(\"thesixmax/desplim\")"},{"path":"https://thesixmax.github.io/desplim/index.html","id":"list-of-functions","dir":"","previous_headings":"","what":"List of functions","title":"DESPLIM algorithm in R","text":"following date list functions available package. Please refer individual man pages vignettes information. Extended documentation, including examples, work progress.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_all_nodes.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute all nodes of an sf LINESTRING object — desplim_all_nodes","title":"Compute all nodes of an sf LINESTRING object — desplim_all_nodes","text":"Function computing nodes sf MULTILINESTRING LINESTRING object.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_all_nodes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute all nodes of an sf LINESTRING object — desplim_all_nodes","text":"","code":"desplim_all_nodes(input_lines, cast_substring = FALSE)"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_all_nodes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute all nodes of an sf LINESTRING object — desplim_all_nodes","text":"input_lines object class sf type LINESTRING MULTILINESTRING. cast_substring logical; input linestrings cast substring? Default FALSE.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_all_nodes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute all nodes of an sf LINESTRING object — desplim_all_nodes","text":"sf object type POINT containing nodes input_lines.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_all_nodes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute all nodes of an sf LINESTRING object — desplim_all_nodes","text":"Function compute nodes sf LINESTRING object, optionally casting input_lines substrings. input_lines contains geometries type MULTILINESTRING, cast LINESTRING computing.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_all_nodes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute all nodes of an sf LINESTRING object — desplim_all_nodes","text":"","code":"# Generate lines line1 <- sf::st_linestring(rbind(c(0, 0), c(1, 1))) line2 <- sf::st_linestring(rbind(c(1, 1), c(2, 0))) combined_sf <- sf::st_as_sf(sf::st_sfc(line1, line2, crs = 4326))  # Compute all nodes all_nodes <- desplim_all_nodes(combined_sf) print(all_nodes) #> Simple feature collection with 3 features and 0 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: 0 xmax: 2 ymax: 1 #> Geodetic CRS:  WGS 84 #>      geometry #> 1 POINT (0 0) #> 2 POINT (1 1) #> 3 POINT (2 0)  # Visualise plot(sf::st_geometry(combined_sf), col = \"slateblue3\", lwd = 2) plot(sf::st_geometry(all_nodes), col = \"tomato3\", pch = 16, cex = 2, add = TRUE)"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_angles.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the minimum and maximum angles between two sf LINESTRING objects — desplim_angles","title":"Calculate the minimum and maximum angles between two sf LINESTRING objects — desplim_angles","text":"Function calculating minimum maximum angles two intersecting sf MULTILINESTRING LINESTRING objects.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_angles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the minimum and maximum angles between two sf LINESTRING objects — desplim_angles","text":"","code":"desplim_angles(input_lines, reference_lines, cast_substring = TRUE)"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_angles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the minimum and maximum angles between two sf LINESTRING objects — desplim_angles","text":"input_lines object class sf type LINESTRING MULTILINESTRING. reference_lines object class sf type LINESTRING MULTILINESTRING. cast_substring logical; input linestrings cast substring? Default TRUE.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_angles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the minimum and maximum angles between two sf LINESTRING objects — desplim_angles","text":"sf object geometries input_lines added columns containing values minimum maximum angle.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_angles.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate the minimum and maximum angles between two sf LINESTRING objects — desplim_angles","text":"input reference lines already cast substring, function can sped , notably setting cast_substring FALSE larger geometries.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_angles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the minimum and maximum angles between two sf LINESTRING objects — desplim_angles","text":"","code":"# Create input and reference lines input_line <- sf::st_linestring(matrix(   c(-1, 0, 0, 0, 1, 0),   ncol = 2,   byrow = TRUE )) ref_line <- sf::st_linestring(matrix(   c(0, -1, 0, 0, -0.5, 1),   ncol = 2,   byrow = TRUE )) input_sf <- sf::st_sf(geom = sf::st_sfc(input_line), crs = 32613) ref_sf <- sf::st_sf(geom = sf::st_sfc(ref_line), crs = 32613)  # Calculate angles angles_sf <- desplim_angles(input_lines = input_sf, reference_lines = ref_sf) print(angles_sf) #> Simple feature collection with 2 features and 2 fields #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: -1 ymin: 0 xmax: 1 ymax: 0 #> Projected CRS: WGS 84 / UTM zone 13N #>                 geometry min_angle max_angle #> 1 LINESTRING (-1 0, 0 0)  63.43495   90.0000 #> 2  LINESTRING (0 0, 1 0)  90.00000  116.5651  # Plot plot(sf::st_geometry(input_sf), col = \"tomato3\", lwd = 2) plot(sf::st_geometry(ref_sf), add = TRUE, col = \"slateblue3\", lwd = 2) text(-0.1, 0.1, paste0(round(angles_sf$min_angle[[1]], 1), \"°\"), pos = 2) text(-0.1, -0.1, paste0(round(angles_sf$max_angle[[1]], 1), \"°\"), pos = 2) text(0.1, 0.1, paste0(round(angles_sf$max_angle[[2]], 1), \"°\"), pos = 4) text(0.1, -0.1, paste0(round(angles_sf$min_angle[[2]], 1), \"°\"), pos = 4)"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_cast_substring.html","id":null,"dir":"Reference","previous_headings":"","what":"Cast an sf LINESTRING or MULTILINESTRING object to substrings — desplim_cast_substring","title":"Cast an sf LINESTRING or MULTILINESTRING object to substrings — desplim_cast_substring","text":"Function computing substrings sf MULTILINESTRING LINESTRING object.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_cast_substring.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cast an sf LINESTRING or MULTILINESTRING object to substrings — desplim_cast_substring","text":"","code":"desplim_cast_substring(input_lines)"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_cast_substring.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cast an sf LINESTRING or MULTILINESTRING object to substrings — desplim_cast_substring","text":"input_lines object class sf geometry type MULTILINESTRING LINESTRING.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_cast_substring.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cast an sf LINESTRING or MULTILINESTRING object to substrings — desplim_cast_substring","text":"sf object type LINESTRING containing substrings input_lines.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_cast_substring.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cast an sf LINESTRING or MULTILINESTRING object to substrings — desplim_cast_substring","text":"avoid issues connecting points spatially separate linestrings, function converts MULTILINESTRING LINESTRING. output always LINESTRING class matching input_lines. Inputs type sfc supported.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_cast_substring.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cast an sf LINESTRING or MULTILINESTRING object to substrings — desplim_cast_substring","text":"","code":"# Create input line input_line <- sf::st_linestring(matrix(   c(-1, 0, 0, 0, 1, 0, 2, 0),   ncol = 2,   byrow = TRUE )) input_sf <- sf::st_sf(geom = sf::st_sfc(input_line), crs = 32613) print(input_sf) #> Simple feature collection with 1 feature and 0 fields #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: -1 ymin: 0 xmax: 2 ymax: 0 #> Projected CRS: WGS 84 / UTM zone 13N #>                             geom #> 1 LINESTRING (-1 0, 0 0, 1 0,... # Cast to substring substring_sf <- desplim_cast_substring(input_sf) print(substring_sf) #> Simple feature collection with 3 features and 0 fields #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: -1 ymin: 0 xmax: 2 ymax: 0 #> Projected CRS: WGS 84 / UTM zone 13N #>                 geometry #> 1 LINESTRING (-1 0, 0 0) #> 2  LINESTRING (0 0, 1 0) #> 3  LINESTRING (1 0, 2 0)"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_compactness.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the 'desplim' compactness of an sf POLYGON object — desplim_compactness","title":"Calculate the 'desplim' compactness of an sf POLYGON object — desplim_compactness","text":"Based approach described Kaufmann et al. (2018), function computes compactness sf POLYGON object.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_compactness.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the 'desplim' compactness of an sf POLYGON object — desplim_compactness","text":"","code":"desplim_compactness(input, keep_metrics = FALSE)"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_compactness.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the 'desplim' compactness of an sf POLYGON object — desplim_compactness","text":"input object class sf type POLYGON MULTIPOLYGON. keep_metrics logical; compactness metrics kept? Default FALSE.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_compactness.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the 'desplim' compactness of an sf POLYGON object — desplim_compactness","text":"sf object type POLYGON matching input, compactness metric(s) added.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_compactness.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate the 'desplim' compactness of an sf POLYGON object — desplim_compactness","text":"Please see dedicated vignette information compactness metric. input contains geometries type MULTIPOLYGON, cast POLYGON computing.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_compactness.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the 'desplim' compactness of an sf POLYGON object — desplim_compactness","text":"","code":"# Create simple plygon polygon_coords <- list(matrix(  c(0, 0, 0, 1, 1, 3, -1, 2, -3, 1, -2, 0, 0, 0),  ncol = 2,  byrow = TRUE )) simple_polygon <- sf::st_sfc(sf::st_polygon(polygon_coords), crs = 4326) input_sf <- sf::st_sf(geometry = simple_polygon) # Calculate compactness compactness_result <- desplim_compactness(input_sf, keep_metrics = TRUE) plot(input_sf)  print(sf::st_drop_geometry(compactness_result)) #>       boyce box_reock      hull   len_wid    polsby     reock  schwartz #> 1 0.8264538 0.5499207 0.9165904 0.7503429 0.5586596 0.3524037 0.7474354 #>        skew    sym_x     sym_y compactness #> 1 0.4282874 0.649081 0.6360927   0.7664453"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_compactness_data.html","id":null,"dir":"Reference","previous_headings":"","what":"DESPLIM compactness data — desplim_compactness_data","title":"DESPLIM compactness data — desplim_compactness_data","text":"Clean data used model DESPLIM compactness metric, based data provided Kaufmann et al (2021). metrics computed using redistmetrics package.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_compactness_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DESPLIM compactness data — desplim_compactness_data","text":"","code":"desplim_compactness_data"},{"path":[]},{"path":"https://thesixmax.github.io/desplim/reference/desplim_compactness_data.html","id":"desplim-compactness-data","dir":"Reference","previous_headings":"","what":"desplim_compactness_data","title":"DESPLIM compactness data — desplim_compactness_data","text":"data frame 558 rows 11 columns: compact District compactness boyce Boyce Clark ratio box_reock Box Reock compactness hull Convex Hull compactness len_wid Length Width compactness polsby Polsby Popper compactness reock Reock compactness schwartz Schwartzberg compactness skew Skew compactness sym_x X symmetry compactness sym_y Y symmetry compactness","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_compactness_data.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"DESPLIM compactness data — desplim_compactness_data","text":"https://dataverse.harvard.edu/file.xhtml?fileId=4143644&version=1.1 https://github.com/aaronrkaufman/compactness/tree/e91519e15fd3ca55f57fc21323bb12ed5a66305b/data https://alarm-redist.org/redistmetrics/","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_connect_border.html","id":null,"dir":"Reference","previous_headings":"","what":"Connect a sf LINESTRING object to border nodes of an sf POLYGON object — desplim_connect_border","title":"Connect a sf LINESTRING object to border nodes of an sf POLYGON object — desplim_connect_border","text":"Compute optimal connections nodes sf LINESTRING object border nodes sf POLYGON object based user input.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_connect_border.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Connect a sf LINESTRING object to border nodes of an sf POLYGON object — desplim_connect_border","text":"","code":"desplim_connect_border(   input_linestring,   input_polygon,   input_buildings = NULL,   distance_intersect = 500,   distance_nodes = 250,   minimum_angle = 30,   num_candidates = 3 )"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_connect_border.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Connect a sf LINESTRING object to border nodes of an sf POLYGON object — desplim_connect_border","text":"input_linestring object class sf type LINESTRING MULTILINESTRING. input_polygon object class sf type POLYGON. input_buildings object class sf type POLYGON MULTIPOLYGON. Contains elements overlap output border connetions. Default NULL. distance_intersect numerical; minimum distance exsting intersections input_linestring border input_polygon border node input_polygon considered new connection. Default 500 units. distance_nodes numerical; maximum distance border nodes input_polygon node input_linestring considered new connection. Default 250 units. minimum_angle numerical; minimum angle new connection border input_polygon required new connection c onsidered. Default 30 degrees. num_candidates numerical; number connections attempt border node. Default 3.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_connect_border.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Connect a sf LINESTRING object to border nodes of an sf POLYGON object — desplim_connect_border","text":"sf object type LINESTRING connecting nodes input_linestring border nodes input_polygon.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_connect_border.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Connect a sf LINESTRING object to border nodes of an sf POLYGON object — desplim_connect_border","text":"candidate border node, num_candidates candidate connections generated. candidate connections meet requirements minimum_angle, fully covered input polygon cross existing linestrings selected. border node closest existing intersection considered first. one valid connection border node found, shortest connection selected set candidate border nodes updated exclude within distance_intersect new connection. valid connection border node exist, border node removed set candidate border nodes.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_connect_border.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Connect a sf LINESTRING object to border nodes of an sf POLYGON object — desplim_connect_border","text":"","code":"# Create input polygon poly_coords <- list(matrix(   c(0, 0, 10, 0, 16, 3, 10, 10, 0, 10, -4, 5, 0, 0),   ncol = 2,   byrow = TRUE )) input_poly <- sf::st_sf(   geometry = sf::st_sfc(sf::st_polygon(poly_coords), crs = 32612) )  # Create input linestring line_coords <- matrix(   c(-4, 5, -2, 5, 7, 8, 9, 6, 9, 1),   ncol = 2,   byrow = TRUE ) input_line <- sf::st_sf(   geometry = sf::st_sfc(sf::st_linestring(line_coords), crs = 32612) )  # Create input building(s) building_coords <- list(matrix(   c(3, 9, 9, 9, 9, 8.5, 3, 8.5, 3, 9),   ncol = 2,   byrow = TRUE )) input_build <- sf::st_sf(   geometry = sf::st_sfc(sf::st_polygon(building_coords), crs = 32612) )  # Function call border_connections <- desplim_connect_border(   input_linestring = input_line,   input_polygon = input_poly,   input_buildings = input_build,   distance_intersect = 3, # Small for example   distance_nodes = 5, # Small for example   minimum_angle = 30,   num_candidates = 3 )  # Visualisation plot(sf::st_geometry(input_poly), border = 'black', lwd = 2) plot(sf::st_geometry(input_build), col = 'tomato3', add = TRUE) plot(sf::st_geometry(input_line), col = 'olivedrab', lwd = 4, add = TRUE) plot(   sf::st_geometry(border_connections),   col = 'slateblue3',   lwd = 3,   lty = 2,   add = TRUE )"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_leaf_nodes.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify leaf nodes of an sf LINESTRING object — desplim_leaf_nodes","title":"Identify leaf nodes of an sf LINESTRING object — desplim_leaf_nodes","text":"Function computing leaf nodes sf MULTILINESTRING LINESTRING object.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_leaf_nodes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify leaf nodes of an sf LINESTRING object — desplim_leaf_nodes","text":"","code":"desplim_leaf_nodes(input_lines)"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_leaf_nodes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify leaf nodes of an sf LINESTRING object — desplim_leaf_nodes","text":"input_lines object class sf type LINESTRING MULTILINESTRING.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_leaf_nodes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify leaf nodes of an sf LINESTRING object — desplim_leaf_nodes","text":"sf object type POINT containing leaf nodes input_lines.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_leaf_nodes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Identify leaf nodes of an sf LINESTRING object — desplim_leaf_nodes","text":"Function compute leaf nodes, .e. nodes intersect one linestring sf LINESTRING object. input_lines contains geometries type MULTILINESTRING, cast LINESTRING computing.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_leaf_nodes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify leaf nodes of an sf LINESTRING object — desplim_leaf_nodes","text":"","code":"# Generate lines line1 <- sf::st_linestring(rbind(c(0, 0), c(1, 1))) line2 <- sf::st_linestring(rbind(c(1, 1), c(2, 2))) line3 <- sf::st_linestring(rbind(c(1, 1), c(1, 0))) combined_sf <- sf::st_as_sf(sf::st_sfc(line1, line2, line3, crs = 4326))  # Compute leaf nodes leaf_nodes <- desplim_leaf_nodes(combined_sf) print(leaf_nodes) #> Simple feature collection with 3 features and 0 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: 0 xmax: 2 ymax: 2 #> Geodetic CRS:  WGS 84 #>      geometry #> 1 POINT (0 0) #> 2 POINT (2 2) #> 3 POINT (1 0)  # Visualise plot(sf::st_geometry(combined_sf), col = \"slateblue3\", lwd = 2) plot(sf::st_geometry(leaf_nodes), col = \"tomato3\", pch = 16, cex = 2, add = TRUE)"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_line_nearest_node.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the minimum distance linestring from an sf POINT object to nodes of a sf LINESTRING object — desplim_line_nearest_node","title":"Calculate the minimum distance linestring from an sf POINT object to nodes of a sf LINESTRING object — desplim_line_nearest_node","text":"Calculate minimum distance linestring connection sf POINT object nodes sf LINESTRING object","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_line_nearest_node.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the minimum distance linestring from an sf POINT object to nodes of a sf LINESTRING object — desplim_line_nearest_node","text":"","code":"desplim_line_nearest_node(   input_nodes,   input_lines,   input_buildings = NULL,   cast_substring = TRUE,   combine_nodes = TRUE,   ignore_equal = TRUE )"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_line_nearest_node.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the minimum distance linestring from an sf POINT object to nodes of a sf LINESTRING object — desplim_line_nearest_node","text":"input_nodes object class sf geometry type POINT MULTIPOINT. input_lines object class sf geometry type LINESTRING MULTILINESTRING. input_buildings optional object class sf geometry type POLYGON MULTIPOLYGON crossed. cast_substring logical; input linestring cast substring? Default TRUE. combine_nodes logical; input nodes nodes input lines combined? Default TRUE. ignore_equal logical; output linestrings exactly equal one elements input_lines ignored? Default TRUE.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_line_nearest_node.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the minimum distance linestring from an sf POINT object to nodes of a sf LINESTRING object — desplim_line_nearest_node","text":"sf object type LINESTRING containing minimum distance linestrings node input_nodes nodes input_lines combined set input_nodes nodes input_lines.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_line_nearest_node.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate the minimum distance linestring from an sf POINT object to nodes of a sf LINESTRING object — desplim_line_nearest_node","text":"input node, function computes minimum distance chosen set nodes outputs minimum distance linestrings. cases minimum distance zero, due overlap input node one nodes input_lines, second minimum distance linestring computed. input_nodes input_lines contain geometries type MULTIPOINT MULTILINESTRING, converted POINT LINESTRING respectively computing.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_line_nearest_node.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the minimum distance linestring from an sf POINT object to nodes of a sf LINESTRING object — desplim_line_nearest_node","text":"","code":"# Create nodes, lines and a building crs <- 32632 line1 <- sf::st_linestring(rbind(c(0, 10), c(10, 10))) line2 <- sf::st_linestring(rbind(c(10, 10), c(10, 0))) lines_sf <- sf::st_as_sf(sf::st_sfc(line1, line2, crs = crs))  node1 <- sf::st_point(c(3, 6)) node2 <- sf::st_point(c(8, 4)) points_sf <- sf::st_as_sf(sf::st_sfc(node1, node2, crs = crs))  building_poly <- sf::st_polygon(list(rbind(   c(1, 7),   c(1, 9),   c(4, 9),   c(4, 7),   c(1, 7) ))) building_sf <- sf::st_as_sf(sf::st_sfc(building_poly, crs = crs))  # Compute connections with no building connections_no_building <- desplim_line_nearest_node(points_sf, lines_sf) print(connections_no_building) #> Simple feature collection with 2 features and 0 fields #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: 0 xmax: 10 ymax: 10 #> Projected CRS: WGS 84 / UTM zone 32N #>                 geometry #> 1 LINESTRING (3 6, 0 10) #> 2 LINESTRING (8 4, 10 0)  # Visualise plot(sf::st_geometry(lines_sf), col = \"black\", lwd = 2) plot(sf::st_geometry(points_sf), col = \"slateblue3\", pch = 16, cex = 2, add = TRUE) plot(sf::st_geometry(connections_no_building), col = \"olivedrab\", lwd = 2, add = TRUE)   # Compute connections with building connections_with_building <- desplim_line_nearest_node(   input_nodes = points_sf,   input_lines = lines_sf,   input_buildings = building_sf ) print(connections_with_building) #> Simple feature collection with 1 feature and 0 fields #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 8 ymin: 0 xmax: 10 ymax: 4 #> Projected CRS: WGS 84 / UTM zone 32N #>                 geometry #> 1 LINESTRING (8 4, 10 0)  # Visualise plot(sf::st_geometry(lines_sf), col = \"black\", lwd = 2) plot(sf::st_geometry(building_sf), col = \"tomato3\", border = NA, add = TRUE) plot(sf::st_geometry(points_sf), col = \"blue\", pch = 16, cex = 2, add = TRUE) plot(sf::st_geometry(connections_with_building), col = \"green\", lwd = 2, add = TRUE)"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_merge.html","id":null,"dir":"Reference","previous_headings":"","what":"Deterministically merge a set of polygons with possible parameters defined by the user. — desplim_merge","title":"Deterministically merge a set of polygons with possible parameters defined by the user. — desplim_merge","text":"Function merging set polygons, optinal rules defined user. merging process deterministic, leading reproducible results subsequent runs input data rules.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_merge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deterministically merge a set of polygons with possible parameters defined by the user. — desplim_merge","text":"","code":"desplim_merge(   input_polygons,   input_buildings = NULL,   compact_method = \"desplim\",   compact_threshold = 0.7,   compact_allow = 0.2,   area_threshold = 10000,   enclosed_threshold = 0.8,   building_threshold = 5 )"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_merge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deterministically merge a set of polygons with possible parameters defined by the user. — desplim_merge","text":"input_polygons object class sf type POLYGON merged. input_buildings object class sf type POLYGON MULTIPOLYGON. optional sf object representing buildings considered merging. Default NULL. compact_method string; chosen method calculating compactness polygons. Default \"desplim\", using internal desplim_compactness function. options include \"polsby\", \"schwartz\" \"convex_hull\" redistmetrics package. compact_threshold numerical; baseline expected compactness output polygons. Default 0.7. compact_allow numerical; fraction polygons allowed fall compact_tolerance. Default 0.2. area_threshold numerical; minimum required area merged polygons. Default 10000 units. enclosed_threshold numerical; fraction polygon border shared single neighbour considered enclosed (flagged merging). Default 0.8. building_threshold integer; minimum number required buildings within merged polygons input_buildings provided. Default 5, sis set 0 input_buildings provided.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_merge.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deterministically merge a set of polygons with possible parameters defined by the user. — desplim_merge","text":"sf object POLYGONs resulting deterministic merge.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_merge.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Deterministically merge a set of polygons with possible parameters defined by the user. — desplim_merge","text":"requirements polygons adjacent . Although named input_buildings, sf object type POLYGON MULTIPOLYGON can provided argument. details compactness metric, please see dedicated vignette. recommended set compact_allow close 1 compact_tolerance low. especially true compact_method set \"polsby\".","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_merge.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Deterministically merge a set of polygons with possible parameters defined by the user. — desplim_merge","text":"","code":"# Create grid crs <- 32632 grid_area <- sf::st_bbox(   c(xmin = 0, ymin = 0, xmax = 1200, ymax = 1000),   crs = crs ) grid_poly <- sf::st_as_sf(sf::st_make_grid(   grid_area,   cellsize = 100,   square = TRUE )) plot(sf::st_geometry(grid_poly), border = 'grey')  # Create buildings n_buildings <- 100 set.seed(420) building_centers <- sf::st_sample(sf::st_as_sfc(grid_area), size = n_buildings) list_of_buildings <- lapply(sf::st_geometry(building_centers), function(point) {   x <- point[1]   y <- point[2]   width <- runif(1, min = 5, max = 20)   height <- runif(1, min = 5, max = 20)   corners <- rbind(     c(x - width / 2, y - height / 2),     c(x + width / 2, y - height / 2),     c(x + width / 2, y + height / 2),     c(x - width / 2, y + height / 2),     c(x - width / 2, y - height / 2)   )   sf::st_as_sf(sf::st_sfc(sf::st_polygon(list(corners))), crs = crs) }) buildings_sf <- do.call(rbind, list_of_buildings) plot(sf::st_geometry(buildings_sf), col = 'slateblue3', border = NA, add = TRUE)  # Merge with default settings grid_merged <- desplim_merge(   input_polygon = grid_poly,   input_buildings = buildings_sf ) #> Linking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.4.0; sf_use_s2() is TRUE print(grid_merged, n = nrow(grid_merged)) #> Simple feature collection with 12 features and 3 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: 0 xmax: 1200 ymax: 1000 #> Projected CRS: WGS 84 / UTM zone 32N #>                          geometry   area compactness building #> 1  POLYGON ((700 700, 700 800,...  20000   0.9410508        5 #> 2  POLYGON ((200 400, 200 500,...  40000   0.9451730        5 #> 3  POLYGON ((0 200, 0 300, 0 4... 100000   0.9327796        7 #> 4  POLYGON ((1000 200, 1000 30... 100000   0.9327796        8 #> 5  POLYGON ((400 600, 400 700,...  40000   0.9451730        5 #> 6  POLYGON ((600 600, 600 700,...  40000   0.9451730        5 #> 7  POLYGON ((0 900, 0 1000, 10... 150000   0.9374167       10 #> 8  POLYGON ((200 300, 300 300,... 160000   0.9030667       15 #> 9  POLYGON ((600 300, 600 400,... 200000   0.9408510       11 #> 10 POLYGON ((400 500, 300 500,...  80000   0.9454119        8 #> 11 POLYGON ((900 700, 900 800,... 170000   0.9297749       13 #> 12 POLYGON ((500 900, 500 1000... 100000   0.9138095        8 plot(sf::st_geometry(grid_merged), lwd = 4, border = 'tomato3', add = TRUE)"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_split.html","id":null,"dir":"Reference","previous_headings":"","what":"Split a polygon based on a sf LINESTRING object and optional border connections. — desplim_split","title":"Split a polygon based on a sf LINESTRING object and optional border connections. — desplim_split","text":"Split polygon based sf LINESTRING object optional border connections.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_split.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Split a polygon based on a sf LINESTRING object and optional border connections. — desplim_split","text":"","code":"desplim_split(   input_polygon,   input_lines,   input_buildings = NULL,   enable_line_nearest_node = TRUE,   enable_border_connect = FALSE,   ... )"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_split.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Split a polygon based on a sf LINESTRING object and optional border connections. — desplim_split","text":"input_polygon object class sf type POLYGON split. input_lines object class sf type LINESTRING MULTILINESTRING used splitting. input_buildings object class sf type POLYGON MULTIPOLYGON. optional sf object representing buildings intersected splitting procedure. Default NULL. enable_line_nearest_node logical; whether connect leaf nodes input_lines nearest node using desplim_line_nearest_node. Default TRUE. enable_border_connect logical; whether connect input_lines border input_polygon using desplim_connect_border. Default FALSE. ... additional arguments passed desplim_connect_border set TRUE.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_split.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Split a polygon based on a sf LINESTRING object and optional border connections. — desplim_split","text":"sf object POLYGONs resulting split.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_split.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Split a polygon based on a sf LINESTRING object and optional border connections. — desplim_split","text":"function splits input polygon based initial set linestrings. enable_line_nearest_node TRUE, leaf nodes input linestrings connected nearest node laid desplim_line_nearest_node. enable_border_connect TRUE, input linestrings connected border input polygon using desplim_connect_border.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_split.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Split a polygon based on a sf LINESTRING object and optional border connections. — desplim_split","text":"","code":"# Create polygon crs <- 32632 district_poly <- sf::st_polygon(list(rbind(   c(0, 0),   c(100, 0),   c(100, 80),   c(90, 90),   c(0, 80),   c(0, 0) ))) district_sf <- sf::st_as_sf(sf::st_sfc(district_poly, crs = crs)) plot(district_sf, border = \"black\", lwd = 2, reset = FALSE)  # Create roads road1 <- sf::st_linestring(rbind(c(5, 5), c(50, 60), c(110, 50))) road2 <- sf::st_linestring(rbind(c(-10, 60), c(20, 40), c(80, 10))) road3 <- sf::st_linestring(rbind(c(-5, 70), c(90, 70), c(90, 20), c(110, 20))) roads_sf <- sf::st_as_sf(sf::st_sfc(road1, road2, road3, crs = crs)) plot(roads_sf, col = \"tomato3\", lwd = 2, add = TRUE)   # Split with no connection split_no_connect <- desplim_split(   district_sf,   roads_sf,   enable_line_nearest_node = FALSE ) plot(split_no_connect, border = \"black\", lwd = 2)   # Split with default settings split_nearest_node <- desplim_split(   district_sf,   roads_sf ) plot(split_nearest_node, border = \"slateblue3\", lwd = 2)   # Split with border connection split_polygons_border <- desplim_split(   district_sf,   roads_sf,   enable_border_connect = TRUE,   distance_nodes = 50,   distance_intersect = 5 ) plot(split_polygons_border, border = \"olivedrab\", lwd = 2)"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_split_merge.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply the DESPLIM algorithm to a set of input polygons and lines. — desplim_split_merge","title":"Apply the DESPLIM algorithm to a set of input polygons and lines. — desplim_split_merge","text":"Apply DESPLIM algorithm set input polygons lines.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_split_merge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply the DESPLIM algorithm to a set of input polygons and lines. — desplim_split_merge","text":"","code":"desplim_split_merge(   input_polygon,   input_lines,   input_buildings = NULL,   line_type_identifier = NULL,   line_type_hierarchy = NULL,   parallel = FALSE,   ... )"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_split_merge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply the DESPLIM algorithm to a set of input polygons and lines. — desplim_split_merge","text":"input_polygon object class sf type POLYGON merged. input_lines object class sf type LINESTRING MULTILINESTRING used splitting. input_buildings object class sf type POLYGON MULTIPOLYGON. optional sf object representing buildings considered splitting merging. Default NULL. line_type_identifier string; name column input_lines contains line type. Default NULL. line_type_hierarchy list; hierarchical structure line types used splitting. Default NULL. types can accessed \"\". parallel logical; whether run split merging steps parallel. TRUE, uses future package, number workers set using plan argument. Default FALSE. ... additional arguments passed desplim_split, desplim_merge desplim_connect_border.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_split_merge.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply the DESPLIM algorithm to a set of input polygons and lines. — desplim_split_merge","text":"sf object POLYGONs resulting merge.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_split_merge.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Apply the DESPLIM algorithm to a set of input polygons and lines. — desplim_split_merge","text":"function applies DESPLIM algorithm set input polygons lines. splitting merging steps performed line desplim_split desplim_merge functions iteration defined line_type_hierarchy.","code":""}]
