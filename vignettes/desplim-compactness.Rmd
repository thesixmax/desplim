---
title: "The DESPLIM compactness score"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{The DESPLIM compactness score}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

When evaluating districts, "compactness" is an important feature. But what makes a district compact? Often, it comes down to the human intuition of "you know it when you see it", which has historically been hard to quantify.

To provide an alternative data-driven measure of compactness, the `desplim` package includes a compactness score that directly models this human intuition. Our approach is based on the work of [Kaufman et al. (2021)](https://doi.org/10.1111/ajps.12603) who successfully trained a model on human rankings of district shapes using common geometric features.

The algorithm may need to calculate several thousands, if not millions, of compactness scores during complex split-merge problems. For this reason, we built our own lightweight and computationally efficient model using [XGBoost](https://cran.r-project.org/web/packages/xgboost/index.html).

This vignette provides an overview of how the metric was developed, using the original [replication data](https://doi.org/10.7910/DVN/FA8FVF) and the [tidyverse](https://www.tidymodels.org/) framework.

## 1. Data and Setup

A cleaned and pre-processed version of this dataset is included directly in `desplim` as `compact_train`.

First, let's load the libraries required for modeling and diagnostics.

```{r setup, message = FALSE}
library(desplim) # contains the cleaned training data
library(tidymodels) # core framework for modelling and pre-processing
library(xgboost) # model engine
library(DALEX) # model explainability
library(DALEXtra) # helper for DALEX
library(doFuture) # parallel processing

# Set up parallel processing
registerDoFuture()
n_cores <- max(1, parallel::detectCores(logical = FALSE) - 1)
plan(multisession, workers = n_cores)
```

The `compact_train` data contains the human-assigned compactness score (`compact`), ranging from 0 (least compact) to 1 (most compact) and 10 geometric features for 558 unique district shapes.

```{r explore-head}
head(compact_train)
```

```{r explore-hist}
hist(compact_train$compact)
```

The histogram shows a relatively uniform distribution of compactness scores, which is ideal for training a model that can recognise the full spectrum from non-compact to highly compact shapes. As the output suggests, no single geometric feature appears to be a perfect predictor on its own.

The following plots show three sample districts from the dataset: one of the least compact, one with a medium score, and one of the most compact. 25 sample districs are provided in the `kaufman_25` dataset.

```{r explore-districts}
library(ggplot2)
library(sf)
library(dplyr)
library(patchwork)
ggplot2::theme_set(ggplot2::theme_minimal(base_size = 14))

# Find districts with high, medium, and low compactness
highly_compact <- kaufman_25 |>
  dplyr::slice_max(order_by = compact, n = 1)

moderately_compact <- kaufman_25 |>
  dplyr::filter(between(compact, 0.4, 0.6)) |>
  dplyr::slice(1)

non_compact <- kaufman_25 |>
  dplyr::slice_min(order_by = compact, n = 1)

# Create plots
p1 <- ggplot(highly_compact) +
  geom_sf() +
  ggtitle(paste("High:", round(highly_compact$compact, 2))) +
  theme_void()

p2 <- ggplot(moderately_compact) +
  geom_sf() +
  ggtitle(paste("Medium:", round(moderately_compact$compact, 2))) +
  theme_void()

p3 <- ggplot(non_compact) +
  geom_sf() +
  ggtitle(paste("Low:", round(non_compact$compact, 2))) +
  theme_void()

p1 + p2 + p3
```

As the plots demonstrate, the scores align well with our visual intuition. The district with the low score is the most "irregular", while the district with the high score is much more "regular".

We'll split the data into a training set (80%) and a testing set (20%). We stratify by the compact variable to ensure both sets have a similar distribution of scores.

```{r data-preparation}
set.seed(123)
# Data split
data_split <- initial_split(compact_train, prop = 0.8, strata = compact)
train_data <- training(data_split)
test_data <- testing(data_split)

# Recipe
model_recipe <- recipe(compact ~ ., data = train_data)
```

## 2. Model specification and tuning

With the data prepared, we can train a model to predict the compactness score based on the 10 geometric features. We'll use the well known XGBoost algorithm for this task. The process involves three main steps: building a workflow, tuning hyperparameters, and finalising the model.

### 2.1 Modelling workflow

First, we define our model specification using tidymodels. We mark standard hyperparameters for tuning, which allows us to find the best combination for our data. For more information, the documentation on the [tune package](https://tune.tidymodels.org/index.html) comes in handy. For the parameter specification, we apply the defaults provided by the [dials package](https://dials.tidymodels.org/).

We then bundle our (simple) pre-processing recipe and the model specification into a single workflow object. Finally, we create a 10-fold cross-validation.

```{r xgb-specification}
# XGBoost specification
xgb_spec <- boost_tree(
  trees = tune(),
  tree_depth = tune(),
  learn_rate = tune(),
  mtry = tune(),
  min_n = tune(),
  loss_reduction = tune(),
  sample_size = tune()
) |>
  set_engine(
    "xgboost",
    objective = "reg:squarederror",
    verbose = 0
  ) |>
  set_mode("regression")

# XGBoost parameter specification
xgb_params <- parameters(
  trees(),
  tree_depth(),
  learn_rate(),
  finalize(mtry(), train_data),
  min_n(),
  loss_reduction(),
  sample_prop()
)

# Workflow
xgb_workflow <- workflow() |>
  add_recipe(model_recipe) |>
  add_model(xgb_spec)

# Cross validation
set.seed(456)
cv_folds <- vfold_cv(train_data, v = 10)
```

### 2.2 Bayesian hyperparameter tuning

Instead of testing every possible combination of parameters (through a grid search), we'll use Bayesian optimisation. This is an adaptive method that uses the results from past iterations to search for the most promising future parameter combinations.

The baseline is 100 iterations, but it will stop early if it doesn't find a better model after 20 rounds. We'll use Root Mean Squared Error (RMSE) as the primary metric to optimise.

```{r bayesian-tuning, cache = TRUE, message = FALSE}
set.seed(789)
tune_results <- tune_bayes(
  xgb_workflow,
  resamples = cv_folds,
  param_info = xgb_params,
  initial = 10,
  iter = 100,
  metrics = metric_set(rmse, mae),
  control = control_bayes(
    verbose_iter = TRUE,
    save_pred = FALSE,
    save_workflow = FALSE,
    uncertain = 5,
    no_improve = 20
  )
)
```

### 2.3 Finalising the model

Once the tuning process is complete, we select the parameters that resulted in the lowest RMSE. We then use the `last_fit()` function, which is a convenient helper that performs the final two steps:

-   Fits the finalised workflow (with the best parameters) on the entire training set.

-   Evaluates the performance of this final model on the held-out test set.

```{r best-params}
# Select the best parameters
best_params <- select_best(tune_results, metric = "rmse")
print(best_params)

# Finalise the workflow
final_xgb_wf <- finalize_workflow(xgb_workflow, best_params)
final_fit <- last_fit(final_xgb_wf, data_split)
```

## 3. Model performance

Having a final, trained model, we need to evaluate its performance on the held-out test data. This tells us how well the model is likely to perform on new, unseen districts.

### 3.1 Overall performance metrics

First, we'll examine the summary performance metrics. The `collect_metrics()` function gives us the Root Mean Squared Error (RMSE) and the R-squared from the test set.

```{r metrics}
test_metrics <- collect_metrics(final_fit)
print(test_metrics)
```

The low RMSE and high R-squared indicate that the model's predictions are, on average, very close to our target compactness scores.

### 3.2 Predicted versus actual scores

Metrics give us a high-level summary, but a plot of predicted versus actual values helps us better understand the model predictions across compactness scores.

```{r predictions}
# Collect the individual predictions on the test set
test_predictions <- collect_predictions(final_fit)

# Create the plot
predicted_vs_actual_plot <- ggplot(
  test_predictions,
  aes(x = compact, y = .pred)
) +
  geom_point(alpha = 0.5, color = "dodgerblue") +
  geom_abline(lty = 2, color = "red", linewidth = 1) +
  labs(
    title = "Predicted vs. actual compactness",
    x = "Actual compactness",
    y = "Predicted compactness"
  ) +
  coord_fixed()

print(predicted_vs_actual_plot)
```

The plot confirms the presumed good performance. Aside from a few outliers, there are no major areas where the model systematically over- or under-predicts, suggesting it generalises well across the entire range of compactness scores.

### 3.3 Feature importance

Finally, we want to understand what geometric features the model relies on most to make its predictions. We can calculate feature importance by measuring how much the model's prediction error increases when a single feature's values are randomly shuffled.

```{r feature-importance}
# Extract the finalised and trained workflow
final_trained_workflow <- extract_workflow(final_fit)

# Create DALEX explainer and feature importance
train_predictors <- train_data |> select(-compact)
train_outcome <- train_data$compact
explainer <- explain_tidymodels(
  final_trained_workflow,
  data = train_predictors,
  y = train_outcome,
  label = "XGBoost"
)
feature_importance <- model_parts(explainer)

# Create summary dataframe
importance_summary_df <- feature_importance %>%
  as_tibble() %>%
  dplyr::filter(variable != "_baseline_" & variable != "_full_model_") %>%
  group_by(variable) %>%
  summarise(
    mean_dropout = mean(dropout_loss),
    min_dropout = min(dropout_loss),
    max_dropout = max(dropout_loss),
    .groups = "drop"
  )

# Create plot
feature_importance_plot <- ggplot(
  importance_summary_df,
  aes(x = mean_dropout, y = reorder(variable, mean_dropout))
) +
  geom_errorbarh(
    aes(xmin = min_dropout, xmax = max_dropout),
    height = 0.2,
    color = "gray50",
    linewidth = 0.9
  ) +
  geom_point(
    color = "darkred",
    size = 3
  ) +
  labs(
    title = "Feature importance",
    x = "Increase in RMSE after feature shuffling",
    y = NULL
  )

print(feature_importance_plot)
```

The results clearly show that Polsby-Popper and Convex Hull are the two most influential features. This aligns with their common usage in (re-)districting analysis and their relation to what is typically perceived as compact. However, all features play a role in predicting the compactness score, justifying a more nuanced model setup.

## 4. Usage

This model is now available in the package through the `desplim_compactness()` function.

The final test is to see how the model's predictions compare to the original compactness scores on the example districts.

```{r usage}
# Apply desplim_compactness to the original example districts
score_high <- desplim_compactness(highly_compact)$compactness
score_moderate <- desplim_compactness(moderately_compact)$compactness
score_low <- desplim_compactness(non_compact)$compactness

# Create comparison plots
p1_final <- ggplot(highly_compact) +
  geom_sf() +
  ggtitle(
    "High Compactness",
    subtitle = paste0(
      "Original: ",
      round(highly_compact$compact, 2),
      "\nModel: ",
      round(score_high, 2)
    )
  ) +
  theme_void()

p2_final <- ggplot(moderately_compact) +
  geom_sf() +
  ggtitle(
    "Medium Compactness",
    subtitle = paste0(
      "Original: ",
      round(moderately_compact$compact, 2),
      "\nModel: ",
      round(score_moderate, 2)
    )
  ) +
  theme_void()

p3_final <- ggplot(non_compact) +
  geom_sf() +
  ggtitle(
    "Low Compactness",
    subtitle = paste0(
      "Original: ",
      round(non_compact$compact, 2),
      "\nModel: ",
      round(score_low, 2)
    )
  ) +
  theme_void()

p1_final + p2_final + p3_final
```

As we can see, the scores from the `desplim_compactness()` function are very close to the original compactness scores.

Finally, we can investigate the example district with the largest deviance between the model prediction and actual compactness score. We set `keep_metrics = TRUE` in  the `desplim_compactness()` function. This returns not just the final score, but also the 10 underlying geometric features, which is useful for diagnosing specific cases.

```{r deviance}
# Calculate deviances
compare_scores <- desplim_compactness(kaufman_25, keep_metrics = TRUE) |>
  mutate(deviance = abs(compact - compactness))

# Find the district with the largest deviance
max_deviance <- compare_scores %>%
  dplyr::slice_max(order_by = deviance, n = 1)

# Plot the result
ggplot(max_deviance) +
  geom_sf(fill = "firebrick", alpha = 0.7) +
  ggtitle(
    "Largest deviance in example data",
    subtitle = paste0(
      "Original score: ",
      round(max_deviance$compact, 2),
      "\nModel score: ",
      round(max_deviance$compactness, 2),
      "\nDeviance: ",
      round(max_deviance$deviance, 2)
    )
  ) +
  theme_void()
```

The main reason for the high deviance is the disagreement between the different geometrical feaures of the district:

```{r deviance-metrics}
print(max_deviance)
```

The shape has a very low polsby score (indicating a highly complex perimeter), while other features are not as low. This example doesn't indicate model failure. It rather highlights that the model is sensitive to perimeter complexity.

```{r session-info, collapse = TRUE}
devtools::session_info()
```