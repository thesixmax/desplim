[{"path":"https://thesixmax.github.io/desplim/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 Sixten Maximillian Thestrup Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://thesixmax.github.io/desplim/articles/DESPLIM-compactness.html","id":"data-and-setup","dir":"Articles","previous_headings":"","what":"1. Data and Setup","title":"Understanding the DESPLIM compactness score","text":"model trained replication data Kaufman et al. (2021). cleaned pre-processed version dataset included directly desplim desplim_compact_data. First, let’s load libraries required modeling diagnostics. desplim_compact_data table contains human-assigned compactness score (compact), ranging 0 (least compact) 1 (compact) 10 geometric features 558 unique district shapes.  histogram shows relatively uniform distribution compactness scores, ideal training model can recognise full spectrum non-compact highly compact shapes. output suggests, single geometric feature perfect predictor . following plots show three sample districts dataset: one least compact, one medium score, one compact. 25 sample districs provided desplim_sf_data dataset.  plots demonstrate, scores align well visual intuition. district low score irregular, district high score much regular, albeit perfectly symmetrical. Finally, ’ll split data training set (80%) testing set (20%). stratify compact variable ensure sets similar distribution scores.","code":"library(desplim) # contains the cleaned training data library(tidymodels) # core framework for modelling and pre-processing library(xgboost) # model engine library(DALEX) # model explainability library(DALEXtra) # helper for DALEX library(doFuture) # parallel processing  # Set up parallel processing registerDoFuture() n_cores <- max(1, parallel::detectCores(logical = FALSE) - 1) plan(multisession, workers = n_cores) head(desplim_compact_data) #>     compact     boyce box_reock      hull   len_wid    polsby     reock #> 1 0.0300000 0.7649550 0.4896064 0.6262075 0.7534825 0.1145953 0.4057489 #> 2 0.2745098 0.7775373 0.4381054 0.6984327 0.8969073 0.2021440 0.3742773 #> 3 0.1300000 0.8304922 0.4871881 0.6415116 0.8888942 0.1258987 0.3280131 #> 4 0.1400000 0.8341214 0.4310280 0.6125937 0.6679481 0.1873192 0.3345650 #> 5 0.0100000 0.7016934 0.4300677 0.5800668 0.9635191 0.1019103 0.4143697 #> 6 0.1176471 0.8371308 0.3508467 0.5589451 0.3416772 0.1458956 0.1486579 #>    schwartz      skew     sym_x     sym_y #> 1 0.3385193 0.2822636 0.6494468 0.5977191 #> 2 0.4496043 0.4190817 0.6090472 0.6896901 #> 3 0.3548220 0.2738264 0.5287228 0.5271888 #> 4 0.4328039 0.3005736 0.4305575 0.3530961 #> 5 0.3192339 0.2754020 0.4761292 0.4987708 #> 6 0.3819629 0.1683645 0.6358400 0.4629123 hist(desplim_compact_data$compact) library(ggplot2) library(sf) #> Linking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.4.0; sf_use_s2() is TRUE library(dplyr) library(patchwork) ggplot2::theme_set(ggplot2::theme_minimal(base_size = 14))  # Find districts with high, medium, and low compactness highly_compact <- desplim_sf_data |>   dplyr::slice_max(order_by = compact, n = 1)  moderately_compact <- desplim_sf_data |>   dplyr::filter(between(compact, 0.4, 0.6)) |>   dplyr::slice(1)  non_compact <- desplim_sf_data |>   dplyr::slice_min(order_by = compact, n = 1)  # Create plots p1 <- ggplot(highly_compact) +   geom_sf() +   ggtitle(paste(\"High:\", round(highly_compact$compact, 2))) +   theme_void()  p2 <- ggplot(moderately_compact) +   geom_sf() +   ggtitle(paste(\"Medium:\", round(moderately_compact$compact, 2))) +   theme_void()  p3 <- ggplot(non_compact) +   geom_sf() +   ggtitle(paste(\"Low:\", round(non_compact$compact, 2))) +   theme_void()  p1 + p2 + p3 set.seed(123) # Data split data_split <- initial_split(desplim_compact_data, prop = 0.8, strata = compact) train_data <- training(data_split) test_data <- testing(data_split)  # Recipe model_recipe <- recipe(compact ~ ., data = train_data)"},{"path":"https://thesixmax.github.io/desplim/articles/DESPLIM-compactness.html","id":"model-specification-and-tuning","dir":"Articles","previous_headings":"","what":"2. Model specification and tuning","title":"Understanding the DESPLIM compactness score","text":"data prepared, can train model predict compactness score based 10 geometric features. ’ll use well known XGBoost algorithm task. process involves three main steps: building workflow, tuning hyperparameters, finalising model.","code":""},{"path":"https://thesixmax.github.io/desplim/articles/DESPLIM-compactness.html","id":"modelling-workflow","dir":"Articles","previous_headings":"2. Model specification and tuning","what":"2.1 Modelling workflow","title":"Understanding the DESPLIM compactness score","text":"First, define model specification using tidymodels. mark standard hyperparameters tuning, allows us find best combination data. information, documentation tune package comes handy. parameter specification, apply defaults provided dials package. bundle (simple) pre-processing recipe model specification single workflow object. Finally, create 10-fold cross-validation.","code":"# XGBoost specification xgb_spec <- boost_tree(   trees = tune(),   tree_depth = tune(),   learn_rate = tune(),   mtry = tune(),   min_n = tune(),   loss_reduction = tune(),   sample_size = tune() ) |>   set_engine(     \"xgboost\",     objective = \"reg:squarederror\",     verbose = 0   ) |>   set_mode(\"regression\")  # XGBoost parameter specification xgb_params <- parameters(   trees(),   tree_depth(),   learn_rate(),   finalize(mtry(), train_data),   min_n(),   loss_reduction(),   sample_prop() )  # Workflow xgb_workflow <- workflow() |>   add_recipe(model_recipe) |>   add_model(xgb_spec)  # Cross validation set.seed(456) cv_folds <- vfold_cv(train_data, v = 10)"},{"path":"https://thesixmax.github.io/desplim/articles/DESPLIM-compactness.html","id":"bayesian-hyperparameter-tuning","dir":"Articles","previous_headings":"2. Model specification and tuning","what":"2.2 Bayesian hyperparameter tuning","title":"Understanding the DESPLIM compactness score","text":"Instead testing every possible combination parameters (grid search), ’ll use Bayesian optimisation. adaptive method uses results past iterations search promising parameter combinations. ’ll let run 100 iterations, stop early doesn’t find better model 20 rounds (no_improve = 20). ’ll use Root Mean Squared Error (RMSE) primary metric optimise.","code":"set.seed(789) tune_results <- tune_bayes(   xgb_workflow,   resamples = cv_folds,   param_info = xgb_params,   initial = 10,   iter = 100,   metrics = metric_set(rmse, mae),   control = control_bayes(     verbose_iter = TRUE,     save_pred = FALSE,     save_workflow = FALSE,     uncertain = 5,     no_improve = 20   ) )"},{"path":"https://thesixmax.github.io/desplim/articles/DESPLIM-compactness.html","id":"finalising-the-model","dir":"Articles","previous_headings":"2. Model specification and tuning","what":"2.3 Finalising the model","title":"Understanding the DESPLIM compactness score","text":"tuning process complete, select parameters resulted lowest RMSE. use last_fit() function, convenient helper performs final two steps: Fits finalised workflow (best parameters) entire training set. Evaluates performance final model held-test set.","code":"# Select the best parameters best_params <- select_best(tune_results, metric = \"rmse\") print(best_params) #> # A tibble: 1 × 8 #>   trees tree_depth learn_rate  mtry min_n loss_reduction sample_size .config #>   <int>      <int>      <dbl> <int> <int>          <dbl>       <dbl> <chr>   #> 1  1200          7    0.00656     6    11       1.21e-10       0.249 iter016  # Finalise the workflow final_xgb_wf <- finalize_workflow(xgb_workflow, best_params) final_fit <- last_fit(final_xgb_wf, data_split)"},{"path":"https://thesixmax.github.io/desplim/articles/DESPLIM-compactness.html","id":"model-performance","dir":"Articles","previous_headings":"","what":"3. Model performance","title":"Understanding the DESPLIM compactness score","text":"final, trained model, need evaluate performance held-test data. tells us well model likely perform new, unseen districts.","code":""},{"path":"https://thesixmax.github.io/desplim/articles/DESPLIM-compactness.html","id":"overall-performance-metrics","dir":"Articles","previous_headings":"3. Model performance","what":"3.1 Overall performance metrics","title":"Understanding the DESPLIM compactness score","text":"First, ’ll examine summary performance metrics. collect_metrics() function gives us Root Mean Squared Error (RMSE) R-squared test set. low RMSE high R-squared indicate model’s predictions , average, close target compactness scores.","code":"test_metrics <- collect_metrics(final_fit) print(test_metrics) #> # A tibble: 2 × 4 #>   .metric .estimator .estimate .config         #>   <chr>   <chr>          <dbl> <chr>           #> 1 rmse    standard      0.0933 pre0_mod0_post0 #> 2 rsq     standard      0.894  pre0_mod0_post0"},{"path":"https://thesixmax.github.io/desplim/articles/DESPLIM-compactness.html","id":"predicted-versus-actual-scores","dir":"Articles","previous_headings":"3. Model performance","what":"3.2 Predicted versus actual scores","title":"Understanding the DESPLIM compactness score","text":"Metrics give us high-level summary, plot predicted versus actual values helps us better understand model predictions across compactness scores.  plot confirms presumed good performance. Aside outliers, major areas model systematically - -predicts, suggesting generalises well across entire range compactness scores.","code":"# Collect the individual predictions on the test set test_predictions <- collect_predictions(final_fit)  # Create the plot predicted_vs_actual_plot <- ggplot(   test_predictions,   aes(x = compact, y = .pred) ) +   geom_point(alpha = 0.5, color = \"dodgerblue\") +   geom_abline(lty = 2, color = \"red\", linewidth = 1) +   labs(     title = \"Predicted vs. actual compactness\",     x = \"Actual compactness\",     y = \"Predicted compactness\"   ) +   coord_fixed()  print(predicted_vs_actual_plot)"},{"path":"https://thesixmax.github.io/desplim/articles/DESPLIM-compactness.html","id":"feature-importance","dir":"Articles","previous_headings":"3. Model performance","what":"3.3 Feature importance","title":"Understanding the DESPLIM compactness score","text":"Finally, want understand geometric features model relies make predictions. can calculate feature importance measuring much model’s prediction error increases single feature’s values randomly shuffled.  results clearly show Polsby-Popper Convex Hull two influential features. aligns common usage (re-)districting analysis relation typically perceived compact. However, features play role predicting compactness score, justifying nuanced model setup.","code":"# Extract the finalised and trained workflow final_trained_workflow <- extract_workflow(final_fit)  # Create DALEX explainer and feature importance train_predictors <- train_data |> select(-compact) train_outcome <- train_data$compact explainer <- explain_tidymodels(   final_trained_workflow,   data = train_predictors,   y = train_outcome,   label = \"XGBoost\" ) #> Preparation of a new explainer is initiated #>   -> model label       :  XGBoost  #>   -> data              :  445  rows  10  cols  #>   -> target variable   :  445  values  #>   -> predict function  :  yhat.workflow  will be used (  default  ) #>   -> predicted values  :  No value for predict function target column. (  default  ) #>   -> model_info        :  package tidymodels , ver. 1.4.1 , task regression (  default  )  #>   -> predicted values  :  numerical, min =  0.063353 , mean =  0.5173986 , max =  0.9554381   #>   -> residual function :  difference between y and yhat (  default  ) #>   -> residuals         :  numerical, min =  -0.1965148 , mean =  -0.0001375619 , max =  0.3349416   #>   A new explainer has been created! feature_importance <- model_parts(explainer)  # Create summary dataframe importance_summary_df <- feature_importance %>%   as_tibble() %>%   dplyr::filter(variable != \"_baseline_\" & variable != \"_full_model_\") %>%   group_by(variable) %>%   summarise(     mean_dropout = mean(dropout_loss),     min_dropout = min(dropout_loss),     max_dropout = max(dropout_loss),     .groups = \"drop\"   )  # Create plot feature_importance_plot <- ggplot(   importance_summary_df,   aes(x = mean_dropout, y = reorder(variable, mean_dropout)) ) +   geom_errorbarh(     aes(xmin = min_dropout, xmax = max_dropout),     height = 0.2,     color = \"gray50\",     linewidth = 0.9   ) +   geom_point(     color = \"darkred\",     size = 3   ) +   labs(     title = \"Feature importance\",     x = \"Increase in RMSE after feature shuffling\",     y = NULL   )  print(feature_importance_plot)"},{"path":"https://thesixmax.github.io/desplim/articles/DESPLIM-compactness.html","id":"usage","dir":"Articles","previous_headings":"","what":"4. Usage","title":"Understanding the DESPLIM compactness score","text":"model now available package desplim_compactness() function. final test see model’s predictions compare original compactness scores example districts.  can see, scores desplim_compactness() function close original compactness scores. Finally, can investigate example district largest deviance model prediction actual compactness score. set keep_metrics = TRUE desplim_compactness function. returns just final score, also 10 underlying geometric features, useful diagnosing specific cases.  main reason high deviance disagreement different geometrical feaures district: shape high convex hull score, low polsby score (indicating highly complex perimeter). example doesn’t indicate model failure. rather highlights model sensitive perimeter complexity, often -weighted intuitively evaluating shape’s overall form.","code":"# Apply desplim_compactness to the original example districts score_high <- desplim_compactness(highly_compact)$compactness #>  #> Attaching package: 'redistmetrics' #> The following object is masked from 'package:dplyr': #>  #>     tally score_moderate <- desplim_compactness(moderately_compact)$compactness score_low <- desplim_compactness(non_compact)$compactness  # Create comparison plots p1_final <- ggplot(highly_compact) +   geom_sf() +   ggtitle(     \"High Compactness\",     subtitle = paste0(       \"Original: \",       round(highly_compact$compact, 2),       \"\\nModel: \",       round(score_high, 2)     )   ) +   theme_void()  p2_final <- ggplot(moderately_compact) +   geom_sf() +   ggtitle(     \"Medium Compactness\",     subtitle = paste0(       \"Original: \",       round(moderately_compact$compact, 2),       \"\\nModel: \",       round(score_moderate, 2)     )   ) +   theme_void()  p3_final <- ggplot(non_compact) +   geom_sf() +   ggtitle(     \"Low Compactness\",     subtitle = paste0(       \"Original: \",       round(non_compact$compact, 2),       \"\\nModel: \",       round(score_low, 2)     )   ) +   theme_void()  p1_final + p2_final + p3_final # This may take a moment as it calculates compactness for all 558 shapes. compare_scores <- desplim_compactness(desplim_sf_data, keep_metrics = TRUE) |>   mutate(deviance = abs(compact - compactness))  # Find the district with the largest deviance max_deviance <- compare_scores %>%   dplyr::slice_max(order_by = deviance, n = 1)  # Plot the result ggplot(max_deviance) +   geom_sf(fill = \"firebrick\", alpha = 0.7) +   ggtitle(     \"Largest deviance in example data\",     subtitle = paste0(       \"Original score: \",       round(max_deviance$compact, 2),       \"\\nModel score: \",       round(max_deviance$compactness, 2),       \"\\nDeviance: \",       round(max_deviance$deviance, 2)     )   ) +   theme_void() print(max_deviance[,c(\"boyce\", \"hull\", \"polsby\", \"reock\", \"sym_x\")]) #> Simple feature collection with 1 feature and 5 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: -93.23186 ymin: 41.8622 xmax: -92.06474 ymax: 42.38496 #> Geodetic CRS:  NAD83 #>       boyce      hull    polsby    reock     sym_x #> 1 0.8865827 0.6883464 0.2839296 0.332486 0.7157668 #>                         geometry #> 1 POLYGON ((-93.23184 41.8657... sessionInfo() #> R version 4.5.1 (2025-06-13) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 24.04.3 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #>  [1] redistmetrics_1.0.9 geos_0.2.4          patchwork_1.3.2     #>  [4] sf_1.0-21           doFuture_1.1.2      future_1.67.0       #>  [7] foreach_1.5.2       DALEXtra_2.3.0      DALEX_2.5.2         #> [10] xgboost_1.7.11.1    yardstick_1.3.2     workflowsets_1.1.1  #> [13] workflows_1.3.0     tune_2.0.0          tidyr_1.3.1         #> [16] tailor_0.1.0        rsample_1.3.1       recipes_1.3.1       #> [19] purrr_1.1.0         parsnip_1.3.3       modeldata_1.5.1     #> [22] infer_1.0.9         ggplot2_3.5.2       dplyr_1.1.4         #> [25] dials_1.4.2         scales_1.4.0        broom_1.0.9         #> [28] tidymodels_1.4.1    desplim_0.1.0       #>  #> loaded via a namespace (and not attached): #>  [1] DBI_1.2.3           rlang_1.1.6         magrittr_2.0.3      #>  [4] furrr_0.3.1         e1071_1.7-16        compiler_4.5.1      #>  [7] systemfonts_1.2.3   vctrs_0.6.5         lhs_1.2.0           #> [10] wk_0.9.4            pkgconfig_2.0.3     fastmap_1.2.0       #> [13] backports_1.5.0     labeling_0.4.3      utf8_1.2.6          #> [16] rmarkdown_2.29      prodlim_2025.04.28  ragg_1.5.0          #> [19] xfun_0.53           cachem_1.1.0        jsonlite_2.0.0      #> [22] parallel_4.5.1      R6_2.6.1            bslib_0.9.0         #> [25] RColorBrewer_1.1-3  parallelly_1.45.1   rpart_4.1.24        #> [28] lubridate_1.9.4     jquerylib_0.1.4     Rcpp_1.1.0          #> [31] iterators_1.0.14    knitr_1.50          future.apply_1.20.0 #> [34] Matrix_1.7-3        splines_4.5.1       nnet_7.3-20         #> [37] timechange_0.3.0    tidyselect_1.2.1    rstudioapi_0.17.1   #> [40] yaml_2.3.10         timeDate_4041.110   codetools_0.2-20    #> [43] listenv_0.9.1       lattice_0.22-7      tibble_3.3.0        #> [46] withr_3.0.2         evaluate_1.0.5      desc_1.4.3          #> [49] survival_3.8-3      units_0.8-7         proxy_0.4-27        #> [52] libgeos_3.11.1-3    pillar_1.11.0       KernSmooth_2.23-26  #> [55] generics_0.1.4      globals_0.18.0      ingredients_2.3.0   #> [58] class_7.3-23        glue_1.8.0          tools_4.5.1         #> [61] data.table_1.17.8   gower_1.0.2         fs_1.6.6            #> [64] grid_4.5.1          ipred_0.9-15        sfd_0.1.0           #> [67] cli_3.6.5           DiceDesign_1.10     textshaping_1.0.3   #> [70] lava_1.8.1          gtable_0.3.6        GPfit_1.0-9         #> [73] sass_0.4.10         digest_0.6.37       classInt_0.4-11     #> [76] farver_2.1.2        htmltools_0.5.8.1   pkgdown_2.1.3       #> [79] lifecycle_1.0.4     hardhat_1.4.2       sparsevctrs_0.3.4   #> [82] MASS_7.3-65"},{"path":"https://thesixmax.github.io/desplim/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Sixten Maximillian Thestrup. Author, maintainer.","code":""},{"path":"https://thesixmax.github.io/desplim/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Thestrup S (2025). desplim: DESPLIM algorithm R. R package version 0.1.0, https://thesixmax.github.io/desplim/.","code":"@Manual{,   title = {desplim: DESPLIM algorithm in R},   author = {Sixten Maximillian Thestrup},   year = {2025},   note = {R package version 0.1.0},   url = {https://thesixmax.github.io/desplim/}, }"},{"path":"https://thesixmax.github.io/desplim/index.html","id":"desplim-implementation-of-the-desplim-algorithm-in-r","dir":"","previous_headings":"","what":"DESPLIM algorithm in R","title":"DESPLIM algorithm in R","text":"package implementation DESPLIM (deterministic split-merge) algorithm geospatial districting R. associated paper forthcoming. Aside main algorithm, package contains several helper functions, can utilised working sf LINESTRING POLYGON data.","code":""},{"path":"https://thesixmax.github.io/desplim/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"DESPLIM algorithm in R","text":"package depends spatial package sf. recommended install package first. Execute following install latest version desplim:","code":"library(devtools) install_github(\"thesixmax/desplim\")"},{"path":"https://thesixmax.github.io/desplim/index.html","id":"list-of-functions","dir":"","previous_headings":"","what":"List of functions","title":"DESPLIM algorithm in R","text":"following date list functions available package. Please refer individual man pages vignettes information. Extended documentation, including examples, work progress.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_all_nodes.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute all nodes of an sf LINESTRING object — desplim_all_nodes","title":"Compute all nodes of an sf LINESTRING object — desplim_all_nodes","text":"Function computing nodes sf MULTILINESTRING LINESTRING object.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_all_nodes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute all nodes of an sf LINESTRING object — desplim_all_nodes","text":"","code":"desplim_all_nodes(input_lines, cast_substring = FALSE)"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_all_nodes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute all nodes of an sf LINESTRING object — desplim_all_nodes","text":"input_lines object class sf type LINESTRING MULTILINESTRING. cast_substring logical; input linestrings cast substring? Default FALSE.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_all_nodes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute all nodes of an sf LINESTRING object — desplim_all_nodes","text":"sf object type POINT containing nodes input_lines.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_all_nodes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute all nodes of an sf LINESTRING object — desplim_all_nodes","text":"Function compute nodes sf LINESTRING object, optionally casting input_lines substrings. input_lines contains geometries type MULTILINESTRING, cast LINESTRING computing.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_all_nodes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute all nodes of an sf LINESTRING object — desplim_all_nodes","text":"","code":"# Generate lines line1 <- sf::st_linestring(rbind(c(0, 0), c(1, 1))) line2 <- sf::st_linestring(rbind(c(1, 1), c(2, 0))) combined_sf <- sf::st_as_sf(sf::st_sfc(line1, line2, crs = 4326))  # Compute all nodes all_nodes <- desplim_all_nodes(combined_sf) print(all_nodes) #> Simple feature collection with 3 features and 0 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: 0 xmax: 2 ymax: 1 #> Geodetic CRS:  WGS 84 #>      geometry #> 1 POINT (0 0) #> 2 POINT (1 1) #> 3 POINT (2 0)  # Visualise plot(sf::st_geometry(combined_sf), col = \"slateblue3\", lwd = 2) plot(sf::st_geometry(all_nodes), col = \"tomato3\", pch = 16, cex = 2, add = TRUE)"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_angles.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the minimum and maximum angles between two sf LINESTRING objects — desplim_angles","title":"Calculate the minimum and maximum angles between two sf LINESTRING objects — desplim_angles","text":"Function calculating minimum maximum angles two intersecting sf MULTILINESTRING LINESTRING objects.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_angles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the minimum and maximum angles between two sf LINESTRING objects — desplim_angles","text":"","code":"desplim_angles(input_lines, reference_lines, cast_substring = TRUE)"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_angles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the minimum and maximum angles between two sf LINESTRING objects — desplim_angles","text":"input_lines object class sf type LINESTRING MULTILINESTRING. reference_lines object class sf type LINESTRING MULTILINESTRING. cast_substring logical; input linestrings cast substring? Default TRUE.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_angles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the minimum and maximum angles between two sf LINESTRING objects — desplim_angles","text":"sf object geometries input_lines added columns containing values minimum maximum angle.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_angles.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate the minimum and maximum angles between two sf LINESTRING objects — desplim_angles","text":"input reference lines already cast substring, function can sped , notably setting cast_substring FALSE larger geometries.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_angles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the minimum and maximum angles between two sf LINESTRING objects — desplim_angles","text":"","code":"# Create input and reference lines input_line <- sf::st_linestring(matrix(   c(-1, 0, 0, 0, 1, 0),   ncol = 2,   byrow = TRUE )) ref_line <- sf::st_linestring(matrix(   c(0, -1, 0, 0, -0.5, 1),   ncol = 2,   byrow = TRUE )) input_sf <- sf::st_sf(geom = sf::st_sfc(input_line), crs = 32613) ref_sf <- sf::st_sf(geom = sf::st_sfc(ref_line), crs = 32613)  # Calculate angles angles_sf <- desplim_angles(input_lines = input_sf, reference_lines = ref_sf) print(angles_sf) #> Simple feature collection with 2 features and 2 fields #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: -1 ymin: 0 xmax: 1 ymax: 0 #> Projected CRS: WGS 84 / UTM zone 13N #>                 geometry min_angle max_angle #> 1 LINESTRING (-1 0, 0 0)  63.43495   90.0000 #> 2  LINESTRING (0 0, 1 0)  90.00000  116.5651  # Plot plot(sf::st_geometry(input_sf), col = \"tomato3\", lwd = 2) plot(sf::st_geometry(ref_sf), add = TRUE, col = \"slateblue3\", lwd = 2) text(-0.1, 0.1, paste0(round(angles_sf$min_angle[[1]], 1), \"°\"), pos = 2) text(-0.1, -0.1, paste0(round(angles_sf$max_angle[[1]], 1), \"°\"), pos = 2) text(0.1, 0.1, paste0(round(angles_sf$max_angle[[2]], 1), \"°\"), pos = 4) text(0.1, -0.1, paste0(round(angles_sf$min_angle[[2]], 1), \"°\"), pos = 4)"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_cast_substring.html","id":null,"dir":"Reference","previous_headings":"","what":"Cast an sf LINESTRING or MULTILINESTRING object to substrings — desplim_cast_substring","title":"Cast an sf LINESTRING or MULTILINESTRING object to substrings — desplim_cast_substring","text":"Function computing substrings sf MULTILINESTRING LINESTRING object.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_cast_substring.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cast an sf LINESTRING or MULTILINESTRING object to substrings — desplim_cast_substring","text":"","code":"desplim_cast_substring(input_lines)"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_cast_substring.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cast an sf LINESTRING or MULTILINESTRING object to substrings — desplim_cast_substring","text":"input_lines object class sf geometry type MULTILINESTRING LINESTRING.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_cast_substring.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cast an sf LINESTRING or MULTILINESTRING object to substrings — desplim_cast_substring","text":"sf object type LINESTRING containing substrings input_lines.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_cast_substring.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cast an sf LINESTRING or MULTILINESTRING object to substrings — desplim_cast_substring","text":"avoid issues connecting points spatially separate linestrings, function converts MULTILINESTRING LINESTRING. output always LINESTRING class matching input_lines. Inputs type sfc supported.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_cast_substring.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cast an sf LINESTRING or MULTILINESTRING object to substrings — desplim_cast_substring","text":"","code":"# Create input line input_line <- sf::st_linestring(matrix(   c(-1, 0, 0, 0, 1, 0, 2, 0),   ncol = 2,   byrow = TRUE )) input_sf <- sf::st_sf(geom = sf::st_sfc(input_line), crs = 32613) print(input_sf) #> Simple feature collection with 1 feature and 0 fields #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: -1 ymin: 0 xmax: 2 ymax: 0 #> Projected CRS: WGS 84 / UTM zone 13N #>                             geom #> 1 LINESTRING (-1 0, 0 0, 1 0,... # Cast to substring substring_sf <- desplim_cast_substring(input_sf) print(substring_sf) #> Simple feature collection with 3 features and 0 fields #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: -1 ymin: 0 xmax: 2 ymax: 0 #> Projected CRS: WGS 84 / UTM zone 13N #>                 geometry #> 1 LINESTRING (-1 0, 0 0) #> 2  LINESTRING (0 0, 1 0) #> 3  LINESTRING (1 0, 2 0)"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_compact_data.html","id":null,"dir":"Reference","previous_headings":"","what":"DESPLIM compactness data — desplim_compact_data","title":"DESPLIM compactness data — desplim_compact_data","text":"Clean data used model DESPLIM compactness metric, based data provided Kaufmann et al. (2021). metrics computed using redistmetrics package.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_compact_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DESPLIM compactness data — desplim_compact_data","text":"","code":"desplim_compact_data"},{"path":[]},{"path":"https://thesixmax.github.io/desplim/reference/desplim_compact_data.html","id":"desplim-compact-data","dir":"Reference","previous_headings":"","what":"desplim_compact_data","title":"DESPLIM compactness data — desplim_compact_data","text":"data frame 558 rows 11 columns: compact District compactness boyce Boyce Clark ratio box_reock Box Reock compactness hull Convex Hull compactness len_wid Length Width compactness polsby Polsby Popper compactness reock Reock compactness schwartz Schwartzberg compactness skew Skew compactness sym_x X symmetry compactness sym_y Y symmetry compactness","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_compact_data.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"DESPLIM compactness data — desplim_compact_data","text":"https://dataverse.harvard.edu/file.xhtml?fileId=4143644&version=1.1 https://github.com/aaronrkaufman/compactness/tree/e91519e15fd3ca55f57fc21323bb12ed5a66305b/data https://alarm-redist.org/redistmetrics/","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_compactness.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the 'desplim' compactness of an sf POLYGON object — desplim_compactness","title":"Calculate the 'desplim' compactness of an sf POLYGON object — desplim_compactness","text":"Based approach described Kaufmann et al. (2018), function computes compactness sf POLYGON object.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_compactness.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the 'desplim' compactness of an sf POLYGON object — desplim_compactness","text":"","code":"desplim_compactness(input, keep_metrics = FALSE)"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_compactness.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the 'desplim' compactness of an sf POLYGON object — desplim_compactness","text":"input object class sf type POLYGON MULTIPOLYGON. keep_metrics logical; compactness metrics kept? Default FALSE.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_compactness.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the 'desplim' compactness of an sf POLYGON object — desplim_compactness","text":"sf object type POLYGON matching input, compactness metric(s) added.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_compactness.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate the 'desplim' compactness of an sf POLYGON object — desplim_compactness","text":"Please see dedicated vignette information compactness metric. input contains geometries type MULTIPOLYGON, cast POLYGON computing.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_compactness.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the 'desplim' compactness of an sf POLYGON object — desplim_compactness","text":"","code":"# Create simple plygon polygon_coords <- list(matrix(  c(0, 0, 0, 1, 1, 3, -1, 2, -3, 1, -2, 0, 0, 0),  ncol = 2,  byrow = TRUE )) simple_polygon <- sf::st_sfc(sf::st_polygon(polygon_coords), crs = 4326) input_sf <- sf::st_sf(geometry = simple_polygon) # Calculate compactness compactness_result <- desplim_compactness(input_sf, keep_metrics = TRUE) plot(input_sf)  print(sf::st_drop_geometry(compactness_result)) #>       boyce box_reock      hull   len_wid    polsby     reock  schwartz #> 1 0.8264538 0.5499207 0.9165904 0.7503429 0.5586596 0.3524037 0.7474354 #>        skew    sym_x     sym_y compactness #> 1 0.4282874 0.649081 0.6360927   0.7664453"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_connect_border.html","id":null,"dir":"Reference","previous_headings":"","what":"Connect a sf LINESTRING object to border nodes of an sf POLYGON object — desplim_connect_border","title":"Connect a sf LINESTRING object to border nodes of an sf POLYGON object — desplim_connect_border","text":"Compute optimal connections nodes sf LINESTRING object border nodes sf POLYGON object based user input.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_connect_border.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Connect a sf LINESTRING object to border nodes of an sf POLYGON object — desplim_connect_border","text":"","code":"desplim_connect_border(   input_linestring,   input_polygon,   input_buildings = NULL,   distance_intersect = 500,   distance_nodes = 250,   minimum_angle = 30,   num_candidates = 3 )"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_connect_border.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Connect a sf LINESTRING object to border nodes of an sf POLYGON object — desplim_connect_border","text":"input_linestring object class sf type LINESTRING MULTILINESTRING. input_polygon object class sf type POLYGON. input_buildings object class sf type POLYGON MULTIPOLYGON. Contains elements overlap output border connetions. Default NULL. distance_intersect numerical; minimum distance exsting intersections input_linestring border input_polygon border node input_polygon considered new connection. Default 500 units. distance_nodes numerical; maximum distance border nodes input_polygon node input_linestring considered new connection. Default 250 units. minimum_angle numerical; minimum angle new connection border input_polygon required new connection c onsidered. Default 30 degrees. num_candidates numerical; number connections attempt border node. Default 3.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_connect_border.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Connect a sf LINESTRING object to border nodes of an sf POLYGON object — desplim_connect_border","text":"sf object type LINESTRING connecting nodes input_linestring border nodes input_polygon.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_connect_border.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Connect a sf LINESTRING object to border nodes of an sf POLYGON object — desplim_connect_border","text":"candidate border node, num_candidates candidate connections generated. candidate connections meet requirements minimum_angle, fully covered input polygon cross existing linestrings selected. border node closest existing intersection considered first. one valid connection border node found, shortest connection selected set candidate border nodes updated exclude within distance_intersect new connection. valid connection border node exist, border node removed set candidate border nodes.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_connect_border.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Connect a sf LINESTRING object to border nodes of an sf POLYGON object — desplim_connect_border","text":"","code":"# Create input polygon poly_coords <- list(matrix(   c(0, 0, 10, 0, 16, 3, 10, 10, 0, 10, -4, 5, 0, 0),   ncol = 2,   byrow = TRUE )) input_poly <- sf::st_sf(   geometry = sf::st_sfc(sf::st_polygon(poly_coords), crs = 32612) )  # Create input linestring line_coords <- matrix(   c(-4, 5, -2, 5, 7, 8, 9, 6, 9, 1),   ncol = 2,   byrow = TRUE ) input_line <- sf::st_sf(   geometry = sf::st_sfc(sf::st_linestring(line_coords), crs = 32612) )  # Create input building(s) building_coords <- list(matrix(   c(3, 9, 9, 9, 9, 8.5, 3, 8.5, 3, 9),   ncol = 2,   byrow = TRUE )) input_build <- sf::st_sf(   geometry = sf::st_sfc(sf::st_polygon(building_coords), crs = 32612) )  # Function call border_connections <- desplim_connect_border(   input_linestring = input_line,   input_polygon = input_poly,   input_buildings = input_build,   distance_intersect = 3, # Small for example   distance_nodes = 5, # Small for example   minimum_angle = 30,   num_candidates = 3 )  # Visualisation plot(sf::st_geometry(input_poly), border = 'black', lwd = 2) plot(sf::st_geometry(input_build), col = 'tomato3', add = TRUE) plot(sf::st_geometry(input_line), col = 'olivedrab', lwd = 4, add = TRUE) plot(   sf::st_geometry(border_connections),   col = 'slateblue3',   lwd = 3,   lty = 2,   add = TRUE )"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_leaf_nodes.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify leaf nodes of an sf LINESTRING object — desplim_leaf_nodes","title":"Identify leaf nodes of an sf LINESTRING object — desplim_leaf_nodes","text":"Function computing leaf nodes sf MULTILINESTRING LINESTRING object.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_leaf_nodes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify leaf nodes of an sf LINESTRING object — desplim_leaf_nodes","text":"","code":"desplim_leaf_nodes(input_lines)"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_leaf_nodes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify leaf nodes of an sf LINESTRING object — desplim_leaf_nodes","text":"input_lines object class sf type LINESTRING MULTILINESTRING.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_leaf_nodes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify leaf nodes of an sf LINESTRING object — desplim_leaf_nodes","text":"sf object type POINT containing leaf nodes input_lines.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_leaf_nodes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Identify leaf nodes of an sf LINESTRING object — desplim_leaf_nodes","text":"Function compute leaf nodes, .e. nodes intersect one linestring sf LINESTRING object. input_lines contains geometries type MULTILINESTRING, cast LINESTRING computing.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_leaf_nodes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify leaf nodes of an sf LINESTRING object — desplim_leaf_nodes","text":"","code":"# Generate lines line1 <- sf::st_linestring(rbind(c(0, 0), c(1, 1))) line2 <- sf::st_linestring(rbind(c(1, 1), c(2, 2))) line3 <- sf::st_linestring(rbind(c(1, 1), c(1, 0))) combined_sf <- sf::st_as_sf(sf::st_sfc(line1, line2, line3, crs = 4326))  # Compute leaf nodes leaf_nodes <- desplim_leaf_nodes(combined_sf) print(leaf_nodes) #> Simple feature collection with 3 features and 0 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: 0 xmax: 2 ymax: 2 #> Geodetic CRS:  WGS 84 #>      geometry #> 1 POINT (0 0) #> 2 POINT (2 2) #> 3 POINT (1 0)  # Visualise plot(sf::st_geometry(combined_sf), col = \"slateblue3\", lwd = 2) plot(sf::st_geometry(leaf_nodes), col = \"tomato3\", pch = 16, cex = 2, add = TRUE)"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_line_nearest_node.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the minimum distance linestring from an sf POINT object to nodes of a sf LINESTRING object — desplim_line_nearest_node","title":"Calculate the minimum distance linestring from an sf POINT object to nodes of a sf LINESTRING object — desplim_line_nearest_node","text":"Calculate minimum distance linestring connection sf POINT object nodes sf LINESTRING object","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_line_nearest_node.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the minimum distance linestring from an sf POINT object to nodes of a sf LINESTRING object — desplim_line_nearest_node","text":"","code":"desplim_line_nearest_node(   input_nodes,   input_lines,   input_buildings = NULL,   cast_substring = TRUE,   combine_nodes = TRUE,   ignore_equal = TRUE )"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_line_nearest_node.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the minimum distance linestring from an sf POINT object to nodes of a sf LINESTRING object — desplim_line_nearest_node","text":"input_nodes object class sf geometry type POINT MULTIPOINT. input_lines object class sf geometry type LINESTRING MULTILINESTRING. input_buildings optional object class sf geometry type POLYGON MULTIPOLYGON crossed. cast_substring logical; input linestring cast substring? Default TRUE. combine_nodes logical; input nodes nodes input lines combined? Default TRUE. ignore_equal logical; output linestrings exactly equal one elements input_lines ignored? Default TRUE.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_line_nearest_node.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the minimum distance linestring from an sf POINT object to nodes of a sf LINESTRING object — desplim_line_nearest_node","text":"sf object type LINESTRING containing minimum distance linestrings node input_nodes nodes input_lines combined set input_nodes nodes input_lines.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_line_nearest_node.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate the minimum distance linestring from an sf POINT object to nodes of a sf LINESTRING object — desplim_line_nearest_node","text":"input node, function computes minimum distance chosen set nodes outputs minimum distance linestrings. cases minimum distance zero, due overlap input node one nodes input_lines, second minimum distance linestring computed. input_nodes input_lines contain geometries type MULTIPOINT MULTILINESTRING, converted POINT LINESTRING respectively computing.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_line_nearest_node.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the minimum distance linestring from an sf POINT object to nodes of a sf LINESTRING object — desplim_line_nearest_node","text":"","code":"# Create nodes, lines and a building crs <- 32632 line1 <- sf::st_linestring(rbind(c(0, 10), c(10, 10))) line2 <- sf::st_linestring(rbind(c(10, 10), c(10, 0))) lines_sf <- sf::st_as_sf(sf::st_sfc(line1, line2, crs = crs))  node1 <- sf::st_point(c(3, 6)) node2 <- sf::st_point(c(8, 4)) points_sf <- sf::st_as_sf(sf::st_sfc(node1, node2, crs = crs))  building_poly <- sf::st_polygon(list(rbind(   c(1, 7),   c(1, 9),   c(4, 9),   c(4, 7),   c(1, 7) ))) building_sf <- sf::st_as_sf(sf::st_sfc(building_poly, crs = crs))  # Compute connections with no building connections_no_building <- desplim_line_nearest_node(points_sf, lines_sf) print(connections_no_building) #> Simple feature collection with 2 features and 0 fields #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: 0 xmax: 10 ymax: 10 #> Projected CRS: WGS 84 / UTM zone 32N #>                 geometry #> 1 LINESTRING (3 6, 0 10) #> 2 LINESTRING (8 4, 10 0)  # Visualise plot(sf::st_geometry(lines_sf), col = \"black\", lwd = 2) plot(sf::st_geometry(points_sf), col = \"slateblue3\", pch = 16, cex = 2, add = TRUE) plot(sf::st_geometry(connections_no_building), col = \"olivedrab\", lwd = 2, add = TRUE)   # Compute connections with building connections_with_building <- desplim_line_nearest_node(   input_nodes = points_sf,   input_lines = lines_sf,   input_buildings = building_sf ) print(connections_with_building) #> Simple feature collection with 1 feature and 0 fields #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 8 ymin: 0 xmax: 10 ymax: 4 #> Projected CRS: WGS 84 / UTM zone 32N #>                 geometry #> 1 LINESTRING (8 4, 10 0)  # Visualise plot(sf::st_geometry(lines_sf), col = \"black\", lwd = 2) plot(sf::st_geometry(building_sf), col = \"tomato3\", border = NA, add = TRUE) plot(sf::st_geometry(points_sf), col = \"blue\", pch = 16, cex = 2, add = TRUE) plot(sf::st_geometry(connections_with_building), col = \"green\", lwd = 2, add = TRUE)"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_merge.html","id":null,"dir":"Reference","previous_headings":"","what":"Deterministically merge a set of polygons with possible parameters defined by the user. — desplim_merge","title":"Deterministically merge a set of polygons with possible parameters defined by the user. — desplim_merge","text":"Function merging set polygons, optinal rules defined user. merging process deterministic, leading reproducible results subsequent runs input data rules.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_merge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deterministically merge a set of polygons with possible parameters defined by the user. — desplim_merge","text":"","code":"desplim_merge(   input_polygons,   input_buildings = NULL,   compact_method = \"desplim\",   compact_threshold = 0.7,   compact_allow = 0.2,   area_threshold = 10000,   enclosed_threshold = 0.8,   building_threshold = 5 )"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_merge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deterministically merge a set of polygons with possible parameters defined by the user. — desplim_merge","text":"input_polygons object class sf type POLYGON merged. input_buildings object class sf type POLYGON MULTIPOLYGON. optional sf object representing buildings considered merging. Default NULL. compact_method string; chosen method calculating compactness polygons. Default \"desplim\", using internal desplim_compactness function. options include \"polsby\", \"schwartz\" \"convex_hull\" redistmetrics package. compact_threshold numerical; baseline expected compactness output polygons. Default 0.7. compact_allow numerical; fraction polygons allowed fall compact_tolerance. Default 0.2. area_threshold numerical; minimum required area merged polygons. Default 10000 units. enclosed_threshold numerical; fraction polygon border shared single neighbour considered enclosed (flagged merging). Default 0.8. building_threshold integer; minimum number required buildings within merged polygons input_buildings provided. Default 5, sis set 0 input_buildings provided.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_merge.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deterministically merge a set of polygons with possible parameters defined by the user. — desplim_merge","text":"sf object POLYGONs resulting deterministic merge.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_merge.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Deterministically merge a set of polygons with possible parameters defined by the user. — desplim_merge","text":"requirements polygons adjacent . Although named input_buildings, sf object type POLYGON MULTIPOLYGON can provided argument. details compactness metric, please see dedicated vignette. recommended set compact_allow close 1 compact_tolerance low. especially true compact_method set \"polsby\".","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_merge.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Deterministically merge a set of polygons with possible parameters defined by the user. — desplim_merge","text":"","code":"# Create grid crs <- 32632 grid_area <- sf::st_bbox(   c(xmin = 0, ymin = 0, xmax = 1200, ymax = 1000),   crs = crs ) grid_poly <- sf::st_as_sf(sf::st_make_grid(   grid_area,   cellsize = 100,   square = TRUE )) plot(sf::st_geometry(grid_poly), border = 'grey')  # Create buildings n_buildings <- 100 set.seed(420) building_centers <- sf::st_sample(sf::st_as_sfc(grid_area), size = n_buildings) list_of_buildings <- lapply(sf::st_geometry(building_centers), function(point) {   x <- point[1]   y <- point[2]   width <- runif(1, min = 5, max = 20)   height <- runif(1, min = 5, max = 20)   corners <- rbind(     c(x - width / 2, y - height / 2),     c(x + width / 2, y - height / 2),     c(x + width / 2, y + height / 2),     c(x - width / 2, y + height / 2),     c(x - width / 2, y - height / 2)   )   sf::st_as_sf(sf::st_sfc(sf::st_polygon(list(corners))), crs = crs) }) buildings_sf <- do.call(rbind, list_of_buildings) plot(sf::st_geometry(buildings_sf), col = 'slateblue3', border = NA, add = TRUE)  # Merge with default settings grid_merged <- desplim_merge(   input_polygon = grid_poly,   input_buildings = buildings_sf ) #> Linking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.4.0; sf_use_s2() is TRUE print(grid_merged, n = nrow(grid_merged)) #> Simple feature collection with 12 features and 3 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: 0 xmax: 1200 ymax: 1000 #> Projected CRS: WGS 84 / UTM zone 32N #>                          geometry   area compactness building #> 1  POLYGON ((700 700, 700 800,...  20000   0.9410508        5 #> 2  POLYGON ((200 400, 200 500,...  40000   0.9451730        5 #> 3  POLYGON ((0 200, 0 300, 0 4... 100000   0.9327796        7 #> 4  POLYGON ((1000 200, 1000 30... 100000   0.9327796        8 #> 5  POLYGON ((400 600, 400 700,...  40000   0.9451730        5 #> 6  POLYGON ((600 600, 600 700,...  40000   0.9451730        5 #> 7  POLYGON ((0 900, 0 1000, 10... 150000   0.9374167       10 #> 8  POLYGON ((200 300, 300 300,... 160000   0.9030667       15 #> 9  POLYGON ((600 300, 600 400,... 200000   0.9408510       11 #> 10 POLYGON ((400 500, 300 500,...  80000   0.9454119        8 #> 11 POLYGON ((900 700, 900 800,... 170000   0.9297749       13 #> 12 POLYGON ((500 900, 500 1000... 100000   0.9138095        8 plot(sf::st_geometry(grid_merged), lwd = 4, border = 'tomato3', add = TRUE)"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_sf_data.html","id":null,"dir":"Reference","previous_headings":"","what":"DESPLIM sf data — desplim_sf_data","title":"DESPLIM sf data — desplim_sf_data","text":"Example districts compactness score data provided Kaufmann et al. (2021).","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_sf_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DESPLIM sf data — desplim_sf_data","text":"","code":"desplim_sf_data"},{"path":[]},{"path":"https://thesixmax.github.io/desplim/reference/desplim_sf_data.html","id":"desplim-sf-data","dir":"Reference","previous_headings":"","what":"desplim_sf_data","title":"DESPLIM sf data — desplim_sf_data","text":"sf data frame 25 rows 2 columns: compact District compactness geometry District shape","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_sf_data.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"DESPLIM sf data — desplim_sf_data","text":"https://dataverse.harvard.edu/file.xhtml?fileId=4143644&version=1.1","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_split.html","id":null,"dir":"Reference","previous_headings":"","what":"Split a polygon based on a sf LINESTRING object and optional border connections. — desplim_split","title":"Split a polygon based on a sf LINESTRING object and optional border connections. — desplim_split","text":"Split polygon based sf LINESTRING object optional border connections.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_split.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Split a polygon based on a sf LINESTRING object and optional border connections. — desplim_split","text":"","code":"desplim_split(   input_polygon,   input_lines,   input_buildings = NULL,   enable_line_nearest_node = TRUE,   enable_border_connect = FALSE,   ... )"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_split.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Split a polygon based on a sf LINESTRING object and optional border connections. — desplim_split","text":"input_polygon object class sf type POLYGON split. input_lines object class sf type LINESTRING MULTILINESTRING used splitting. input_buildings object class sf type POLYGON MULTIPOLYGON. optional sf object representing buildings intersected splitting procedure. Default NULL. enable_line_nearest_node logical; whether connect leaf nodes input_lines nearest node using desplim_line_nearest_node. Default TRUE. enable_border_connect logical; whether connect input_lines border input_polygon using desplim_connect_border. Default FALSE. ... additional arguments passed desplim_connect_border set TRUE.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_split.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Split a polygon based on a sf LINESTRING object and optional border connections. — desplim_split","text":"sf object POLYGONs resulting split.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_split.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Split a polygon based on a sf LINESTRING object and optional border connections. — desplim_split","text":"function splits input polygon based initial set linestrings. enable_line_nearest_node TRUE, leaf nodes input linestrings connected nearest node laid desplim_line_nearest_node. enable_border_connect TRUE, input linestrings connected border input polygon using desplim_connect_border.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_split.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Split a polygon based on a sf LINESTRING object and optional border connections. — desplim_split","text":"","code":"# Create polygon crs <- 32632 district_poly <- sf::st_polygon(list(rbind(   c(0, 0),   c(100, 0),   c(100, 80),   c(90, 90),   c(0, 80),   c(0, 0) ))) district_sf <- sf::st_as_sf(sf::st_sfc(district_poly, crs = crs)) plot(district_sf, border = \"black\", lwd = 2, reset = FALSE)  # Create roads road1 <- sf::st_linestring(rbind(c(5, 5), c(50, 60), c(110, 50))) road2 <- sf::st_linestring(rbind(c(-10, 60), c(20, 40), c(80, 10))) road3 <- sf::st_linestring(rbind(c(-5, 70), c(90, 70), c(90, 20), c(110, 20))) roads_sf <- sf::st_as_sf(sf::st_sfc(road1, road2, road3, crs = crs)) plot(roads_sf, col = \"tomato3\", lwd = 2, add = TRUE)   # Split with no connection split_no_connect <- desplim_split(   district_sf,   roads_sf,   enable_line_nearest_node = FALSE ) plot(split_no_connect, border = \"black\", lwd = 2)   # Split with default settings split_nearest_node <- desplim_split(   district_sf,   roads_sf ) plot(split_nearest_node, border = \"slateblue3\", lwd = 2)   # Split with border connection split_polygons_border <- desplim_split(   district_sf,   roads_sf,   enable_border_connect = TRUE,   distance_nodes = 50,   distance_intersect = 5 ) plot(split_polygons_border, border = \"olivedrab\", lwd = 2)"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_split_merge.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply the DESPLIM algorithm to a set of input polygons and lines. — desplim_split_merge","title":"Apply the DESPLIM algorithm to a set of input polygons and lines. — desplim_split_merge","text":"Apply DESPLIM algorithm set input polygons lines.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_split_merge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply the DESPLIM algorithm to a set of input polygons and lines. — desplim_split_merge","text":"","code":"desplim_split_merge(   input_polygon,   input_lines,   input_buildings = NULL,   line_type_identifier = NULL,   line_type_hierarchy = NULL,   parallel = FALSE,   ... )"},{"path":"https://thesixmax.github.io/desplim/reference/desplim_split_merge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply the DESPLIM algorithm to a set of input polygons and lines. — desplim_split_merge","text":"input_polygon object class sf type POLYGON merged. input_lines object class sf type LINESTRING MULTILINESTRING used splitting. input_buildings object class sf type POLYGON MULTIPOLYGON. optional sf object representing buildings considered splitting merging. Default NULL. line_type_identifier string; name column input_lines contains line type. Default NULL. line_type_hierarchy list; hierarchical structure line types used splitting. Default NULL. types can accessed \"\". parallel logical; whether run split merging steps parallel. TRUE, uses future package, number workers set using plan argument. Default FALSE. ... additional arguments passed desplim_split, desplim_merge desplim_connect_border.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_split_merge.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply the DESPLIM algorithm to a set of input polygons and lines. — desplim_split_merge","text":"sf object POLYGONs resulting merge.","code":""},{"path":"https://thesixmax.github.io/desplim/reference/desplim_split_merge.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Apply the DESPLIM algorithm to a set of input polygons and lines. — desplim_split_merge","text":"function applies DESPLIM algorithm set input polygons lines. splitting merging steps performed line desplim_split desplim_merge functions iteration defined line_type_hierarchy.","code":""}]
